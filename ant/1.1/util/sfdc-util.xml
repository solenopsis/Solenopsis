<!--
# Copyright 2011 Red Hat Inc.
#
# This file is part of solenopsis
#
# solenopsis is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-->
<project name="SFDC Utilities" basedir="." xmlns:ac="http://ant-contrib.sourceforge.net" xmlns:sf="antlib:com.salesforce" xmlns:rh-util="http://www.redhat.com/util"  xmlns:rh-sfdc="http://www.redhat.com/sfdc">

    <!-- =========================================================================================== -->

	<import file="rh-util.xml"/>

    <!-- =========================================================================================== -->

	<!--
		Try to find the salesforce jar!
	-->
	<property name="sfdc-util.SF-JAR.PATH" value="${sf.antFile}${line.separator}${user.dir}/ant-salesforce.jar${line.separator}${user.home}/.ant/lib/ant-salesforce.jar${line.separator}/usr/share/ant/lib/ant-salesforce.jar${line.separator}${solenopsis.lib.HOME}/ant-salesforce.jar"/>

	<ac:for list="${sfdc-util.SF-JAR.PATH}" param="sfdc-util.SF-JAR" delimiter="${line.separator}">
		<sequential>
			<rh-util:ifNotSet property="sf.migrationToolJar">
				<rh-util:then>
					<available property="sf.migrationToolJar" value="@{sfdc-util.SF-JAR}" file="@{sfdc-util.SF-JAR}"/>
				</rh-util:then>
			</rh-util:ifNotSet>
		</sequential>
	</ac:for>

	<fail unless="sf.migrationToolJar">

Could not find the Saleforce Ant Library!  The jar should exist as one of the following:

${sfdc-util.SF-JAR.PATH}

	</fail>

    <!-- =========================================================================================== -->

	<property file="${solenopsis.props.HOME}/sfdc.metadata.properties"/>

    <!-- =========================================================================================== -->

	<!--
		Setup various properties for the specified environments...
	-->
	<ac:for list="${solenopsis.ENVIRONMENTS}" param="solenopsis.env.SANDBOX" delimiter=" ">
		<sequential>
			<property name="solenopsis.env.@{solenopsis.env.SANDBOX}.HOME" value="${solenopsis.env.HOME}/env/@{solenopsis.env.SANDBOX}"/>
		</sequential>
	</ac:for>

    <!-- =========================================================================================== -->

    <taskdef resource="com/salesforce/antlib.xml" uri="antlib:com.salesforce" description="Salesforce Migration Tool">
        <classpath>
            <fileset file="${sf.migrationToolJar}"/>
        </classpath>
    </taskdef>

    <!-- =========================================================================================== -->

	<macrodef name="xml-name" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the name XML element">
		<attribute name="property" description="Property to store the XML name element"/>
		<attribute name="value"    description="The value for the name element"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<rh-util:xmlElement property="@{property}" name="name" value="@{value}" prefix="        " elementDelimiter="@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xml-members" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the members XML element">
		<attribute name="property" description="Property to store the XML members element"/>
		<attribute name="value"    description="The value for the members element"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The elementDelimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<rh-util:xmlElement property="@{property}" name="members" value="@{value}" prefix="        " elementDelimiter="@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xml-types" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the types XML element - members elements generated from the @{members} (space delimited values)">
		<attribute name="property" description="Property to store the XML for types where members are the wildcard"/>
		<attribute name="name"     description="The value for the name child element"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<element name="Children" optional="true" implicit="yes" description="Any processing that should occur within the package construction"/>

		<sequential>
			<rh-util:xmlElementContainer property="@{property}" name="types" prefix="    " elementDelimiter="@{elementDelimiter}">
				<Children/>

				<rh-sfdc:xml-name property="@{property}" value="@{name}" elementDelimiter="@{elementDelimiter}"/>
			</rh-util:xmlElementContainer>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xml-version" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate XML version element.  The value for the version is contained with @{version}">
		<attribute name="property" description="Property to store the XML version element"/>
		<attribute name="value" default="${sf.version}" description="The value for the version element"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<rh-util:xmlElement property="@{property}" name="version" value="@{value}" prefix="    " elementDelimiter="@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xml-package" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the package XML element - mostly empty">
		<attribute name="property" description="Property to store the XML for types where members are the wildcard"/>
		<attribute name="namespace"        default="${sf.namespace}"   description="The package namespace"/>
		<attribute name="version"          default="${sf.version}"     description="The value for the version child elements"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<element name="Children" implicit="yes" optional="true" description="Any folder based processing"/>

		<sequential>
			<!--
				Reset the property holding the package values, as we cannot have more than
				the root package element!!!
			-->
			<rh-util:property name="@{property}" value=""/>

			<rh-util:xmlElementContainer property="@{property}" name="package" namespace="@{namespace}" elementDelimiter="@{elementDelimiter}">
				<Children/>

				<rh-sfdc:xml-version property="@{property}" value="@{version}" elementDelimiter="@{elementDelimiter}"/>
			</rh-util:xmlElementContainer>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="members-xml-types" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the types XML element for those types that have fixed members (notably objects)">
		<attribute name="property" description="Property to store the XML for types where members are the wildcard"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<!--
				Iterate over the property names for members.  Each property should be a list of actual members.
			-->
			<rh-util:processPropertyAsList property="sf.members" param="members-xml-types.MEMBERS">
				<fail unless="@{members-xml-types.MEMBERS}.name" message="MISSING PROPERTY:  @{members-xml-types.MEMBERS}.name"/>

				<rh-util:propertyDereference name="members-xml-types.MEMBERS-NAME" property="${@{members-xml-types.MEMBERS}.name}"/>
				<rh-sfdc:xml-types property="@{property}" name="${members-xml-types.MEMBERS-NAME}" elementDelimiter="@{elementDelimiter}">
					<rh-util:processPropertyAsList property="@{members-xml-types.MEMBERS}.values" param="members-xml-types.SINGLE-MEMBER">
						<rh-sfdc:xml-members property="@{property}" value="@{members-xml-types.SINGLE-MEMBER}" elementDelimiter="@{elementDelimiter}"/>
					</rh-util:processPropertyAsList>
				</rh-sfdc:xml-types>
			</rh-util:processPropertyAsList>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="bean-shell" uri="http://www.redhat.com/sfdc" language="beanshell" description="Computes the XSLT to apply using the sfdcignore file">
        <classpath refid="solenopsis.script.PATH"/>

		<![CDATA[
        /*
            //addClassPath(project.getProperty("solenopsis.bsh.HOME"));
            addClassPath(project.getProperty("/home/sfloess/Development/github/solenopsis/Solenopsis/bsh");


            //System.out.println("Is this blank: " + su.isBlank("foo"));
            */

            importCommands(".");

            su = StringUtils();
            System.out.println("Is this blank: " + su.isBlank("foo"));
            print ("Hello");
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

    <scriptdef name="createPackageXmlChildren" uri="http://www.redhat.com/sfdc" language="beanshell" description="Computes the XSLT to apply using the sfdcignore file">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="property"/>
        <attribute name="fileList"/>
        <attribute name="fieldList"/>
        <attribute name="fileDelimiter"/>
        <attribute name="version"/>
        <attribute name="isDestructiveChange"/>

		<![CDATA[
            Map xmlMap = new TreeMap();     // Dir name to XML name...
            xmlMap.put("installedPackages", "InstalledPackage");
            xmlMap.put("labels", "CustomLabels");
            xmlMap.put("staticresources", "StaticResource");
            xmlMap.put("scontrols", "Scontrol");
            xmlMap.put("components", "ApexComponent");
            xmlMap.put("pages", "ApexPage");
            xmlMap.put("queues", "Queue");
            xmlMap.put("dataSources", "ExternalDataSource");
            xmlMap.put("roles", "Role");
            xmlMap.put("groups", "Group");
            xmlMap.put("objects", "CustomObject");
            xmlMap.put("reportTypes", "ReportType");
            xmlMap.put("reports", "Report");
            xmlMap.put("dashboards", "Dashboard");
            xmlMap.put("analyticSnapshots", "AnalyticSnapshot");
            xmlMap.put("layouts", "Layout");
            xmlMap.put("documents", "Document");
            xmlMap.put("weblinks", "CustomPageWebLink");
            xmlMap.put("quickActions", "QuickAction");
            xmlMap.put("flexipages", "FlexiPage");
            xmlMap.put("tabs", "CustomTab");
            xmlMap.put("customApplicationComponents", "CustomApplicationComponent");
            xmlMap.put("applications", "CustomApplication");
            xmlMap.put("portals", "Portal");
            xmlMap.put("letterhead", "Letterhead");
            xmlMap.put("email", "EmailTemplate");
            xmlMap.put("flows", "Flow");
            xmlMap.put("flowDefinitions", "FlowDefinition");
            xmlMap.put("workflows", "Workflow");
            xmlMap.put("assignmentRules", "AssignmentRules");
            xmlMap.put("autoResponseRules", "AutoResponseRules");
            xmlMap.put("escalationRules", "EscalationRules");
            xmlMap.put("postTemplates", "PostTemplate");
            xmlMap.put("approvalProcesses", "ApprovalProcess");
            xmlMap.put("homePageComponents", "HomePageComponent");
            xmlMap.put("homePageLayouts", "HomePageLayout");
            xmlMap.put("objectTranslations", "CustomObjectTranslation");
            xmlMap.put("classes", "ApexClass");
            xmlMap.put("triggers", "ApexTrigger");
            xmlMap.put("profiles", "Profile");
            xmlMap.put("permissionsets", "PermissionSet");
            xmlMap.put("datacategorygroups", "DataCategoryGroup");
            xmlMap.put("remoteSiteSettings", "RemoteSiteSetting");
            xmlMap.put("authproviders", "AuthProvider");
            xmlMap.put("sites", "CustomSite");
            xmlMap.put("leadSharingRules", "LeadSharingRules");
            xmlMap.put("campaignSharingRules", "CampaignSharingRules");
            xmlMap.put("caseSharingRules", "CaseSharingRules");
            xmlMap.put("contactSharingRules", "ContactSharingRules");
            xmlMap.put("opportunitySharingRules", "OpportunitySharingRules");
            xmlMap.put("accountSharingRules", "AccountSharingRules");
            xmlMap.put("customObjectSharingRules", "CustomObjectSharingRules");
            xmlMap.put("userSharingRules", "UserSharingRules");
            xmlMap.put("sharingSets", "SharingSet");
            xmlMap.put("communities", "Community");
            xmlMap.put("callCenters", "CallCenter");
            xmlMap.put("entitlementProcesses", "EntitlementProcess");
            xmlMap.put("milestoneTypes", "MilestoneType");
            xmlMap.put("entitlementTemplates", "EntitlementTemplate");
            xmlMap.put("connectedApps", "ConnectedApp");
            xmlMap.put("appMenus", "AppMenu");
            xmlMap.put("siteDotComSites", "SiteDotCom");
            xmlMap.put("skills", "Skill");
            xmlMap.put("liveChatDeployments", "LiveChatDeployment");
            xmlMap.put("liveChatButtons", "LiveChatButton");
            xmlMap.put("liveChatAgentConfigs", "LiveChatAgentConfig");
            xmlMap.put("settings", "Settings");
            xmlMap.put("globalPicklists", "GlobalPicklist");
            xmlMap.put("globalValueSets", "GlobalValueSet");
            xmlMap.put("globalValueSetTranslations", "GlobalValueSetTranslation");
            xmlMap.put("standardValueSets", "StandardValueSet");
			xmlMap.put("entitlementProcesses", "EntitlementProcess");
			xmlMap.put("milestoneTypes", "MilestoneType");
			xmlMap.put("customMetadata", "CustomMetadata");

            Map suffixMap = new TreeMap();     // Dir name to suffix...
            suffixMap.put("installedPackages", "installedPackage");
            suffixMap.put("labels", "labels");
            suffixMap.put("staticresources", "resource");
            suffixMap.put("scontrols", "scf");
            suffixMap.put("components", "component");
            suffixMap.put("pages", "page");
            suffixMap.put("queues", "queue");
            suffixMap.put("dataSources", "dataSource");
            suffixMap.put("roles", "role");
            suffixMap.put("groups", "group");
            suffixMap.put("objects", "object");
            suffixMap.put("reportTypes", "reportType");
            suffixMap.put("reports", "report");
            suffixMap.put("dashboards", "dashboard");
            suffixMap.put("analyticSnapshots", "snapshot");
            suffixMap.put("layouts", "layout");
            suffixMap.put("weblinks", "weblink");
            suffixMap.put("quickActions", "quickAction");
            suffixMap.put("flexipages", "flexipage");
            suffixMap.put("tabs", "tab");
            suffixMap.put("customApplicationComponents", "customApplicationComponent");
            suffixMap.put("applications", "app");
            suffixMap.put("portals", "portal");
            suffixMap.put("letterhead", "letter");
            suffixMap.put("email", "email");
            suffixMap.put("flows", "flow");
            suffixMap.put("flowDefinitions", "flowDefinition");
            suffixMap.put("workflows", "workflow");
            suffixMap.put("assignmentRules", "assignmentRules");
            suffixMap.put("autoResponseRules", "autoResponseRules");
            suffixMap.put("escalationRules", "escalationRules");
            suffixMap.put("postTemplates", "postTemplate");
            suffixMap.put("approvalProcesses", "approvalProcess");
            suffixMap.put("homePageComponents", "homePageComponent");
            suffixMap.put("homePageLayouts", "homePageLayout");
            suffixMap.put("objectTranslations", "objectTranslation");
            suffixMap.put("classes", "cls");
            suffixMap.put("triggers", "trigger");
            suffixMap.put("profiles", "profile");
            suffixMap.put("permissionsets", "permissionset");
            suffixMap.put("datacategorygroups", "datacategorygroup");
            suffixMap.put("remoteSiteSettings", "remoteSite");
            suffixMap.put("authproviders", "authprovider");
            suffixMap.put("sites", "site");
            suffixMap.put("leadSharingRules", "sharingRules");
            suffixMap.put("campaignSharingRules", "sharingRules");
            suffixMap.put("caseSharingRules", "sharingRules");
            suffixMap.put("contactSharingRules", "sharingRules");
            suffixMap.put("opportunitySharingRules", "sharingRules");
            suffixMap.put("accountSharingRules", "sharingRules");
            suffixMap.put("customObjectSharingRules", "sharingRules");
            suffixMap.put("userSharingRules", "sharingRules");
            suffixMap.put("sharingSets", "sharingRules");
            suffixMap.put("communities", "community");
            suffixMap.put("callCenters", "callCenter");
            suffixMap.put("entitlementProcesses", "entitlementProcess");
            suffixMap.put("milestoneTypes", "milestoneType");
            suffixMap.put("entitlementTemplates", "entitlementTemplate");
            suffixMap.put("connectedApps", "connectedApp");
            suffixMap.put("appMenus", "appMenu");
            suffixMap.put("siteDotComSites", "site");
            suffixMap.put("skills", "skill");
            suffixMap.put("liveChatDeployments", "liveChatDeployment");
            suffixMap.put("liveChatButtons", "liveChatButton");
            suffixMap.put("liveChatAgentConfigs", "liveChatAgentConfig");
            suffixMap.put("settings", "settings");
            suffixMap.put("globalPicklists", "globalPicklist");
            suffixMap.put("globalValueSets", "globalValueSet");
            suffixMap.put("globalValueSetTranslations", "globalValueSetTranslation");
            suffixMap.put("standardValueSets", "standardValueSet");
			suffixMap.put("entitlementProcesses", "entitlementProcess");
			suffixMap.put("milestoneTypes", "milestoneType");

            Set wildcardSet = new TreeSet();     // Dir name to wildcard...
            wildcardSet.add("installedPackages");
            wildcardSet.add("staticresources");
            wildcardSet.add("scontrols");
            wildcardSet.add("components");
            wildcardSet.add("pages");
            wildcardSet.add("queues");
            wildcardSet.add("dataSources");
            wildcardSet.add("roles");
            wildcardSet.add("groups");
            wildcardSet.add("reportTypes");
            wildcardSet.add("layouts");
            wildcardSet.add("weblinks");
            wildcardSet.add("quickActions");
            wildcardSet.add("flexipages");
            wildcardSet.add("tabs");
            wildcardSet.add("customApplicationComponents");
            wildcardSet.add("applications");
            wildcardSet.add("portals");
            wildcardSet.add("flows");
            wildcardSet.add("flowDefinitons");
            wildcardSet.add("workflows");
            wildcardSet.add("assignmentRules");
            wildcardSet.add("autoResponseRules");
            wildcardSet.add("postTemplates");
            wildcardSet.add("homePageComponents");
            wildcardSet.add("homePageLayouts");
            wildcardSet.add("objectTranslations");
            wildcardSet.add("classes");
            wildcardSet.add("triggers");
            wildcardSet.add("profiles");
            wildcardSet.add("permissionsets");
            wildcardSet.add("datacategorygroups");
            wildcardSet.add("remoteSiteSettings");
            wildcardSet.add("authproviders");
            wildcardSet.add("sites");
            wildcardSet.add("sharingSets");
            wildcardSet.add("communities");
            wildcardSet.add("callCenters");
            wildcardSet.add("entitlementProcesses");
            wildcardSet.add("milestoneTypes");
            wildcardSet.add("entitlementTemplates");
            wildcardSet.add("connectedApps");
            wildcardSet.add("appMenus");
            wildcardSet.add("siteDotComSites");
            wildcardSet.add("skills");
            wildcardSet.add("liveChatDeployments");
            wildcardSet.add("liveChatButtons");
            wildcardSet.add("liveChatAgentConfigs");
            wildcardSet.add("globalPicklists");
            wildcardSet.add("globalValueSets");
            wildcardSet.add("globalValueSetTranslations");
            wildcardSet.add("standardValueSets");
			wildcardSet.add("entitlementProcesses");
			wildcardSet.add("milestoneTypes");

            Set folderSet = new TreeSet();  // Dir name to folder.
            folderSet.add("reports");
            folderSet.add("dashboards");
            folderSet.add("documents");
            folderSet.add("email");

            String getFileDelimiter(String delim) {
                return (null == delim ? System.getProperty("path.separator") : delim);
            }

            String getDir(String file) {
                File parent = new File(file).getParentFile();

                if (null == parent) {
                    System.out.println("WARNING:  No parent found for [" + file + "]");

                    return null;
                }

                return null == parent.getParentFile() ?  parent.getName() : parent.getParentFile().getName();
            }

            TreeSet getFileSet(Map xmlMap, String dirName) {
                if (!xmlMap.containsKey(dirName)) {
                    xmlMap.put(dirName, new TreeSet());
                }

                return xmlMap.get(dirName);
            }

            boolean isBlankFileName(String fileName) {
                return null == fileName || "".equals(fileName) || "".equals(fileName.trim());
            }

            boolean isPackageXmlFile(String fileName) {
                return "package.xml".equals(fileName.trim());
            }

            boolean isMetaXmlFile(String fileName) {
                return fileName.trim().endsWith("-meta.xml");
            }

            boolean isFileSkip(String fileName) {
                return  isBlankFileName(fileName) || isPackageXmlFile(fileName) || isMetaXmlFile(fileName);
            }

            int getExtensionIndex(int lastIndex, int fileNameLength) {
                return lastIndex == -1 ? fileNameLength : lastIndex;
            }

            int getExtensionIndex(String fileName) {
                return getExtensionIndex(fileName.lastIndexOf('.'), fileName.length());
            }

            String removeExtension(String fileName) {
                return fileName.substring(0, getExtensionIndex(fileName));
            }

            String removeExtension(File file) {
                if (null == file.getParentFile().getParentFile()) {
                    return removeExtension(file.getName());
                }

                return removeExtension(file.getParentFile().getName() + File.separator + file.getName());
            }

            void addFile(Map xmlMap, String fileName) {
                if (isFileSkip(fileName)) {
                    return;
                }

                String dir = getDir(fileName);
                if (null == dir) {
                    System.out.println("WARNING:  Cannot add [" + fileName + "]");
                    return;
                }

                getFileSet(xmlMap, dir).add(removeExtension(new File(fileName)));
            }

            Map computeActualElements(String[] files) {
                final Map retVal = new TreeMap();

                for (String aFile : files) {
                    addFile(retVal, aFile);
                }

                return retVal;
            }

            void addMember(StringBuilder sb, String member) {
                sb.append("        <members>").append(member).append("</members>\n");
            }

            void addMembers(StringBuilder sb, TreeSet files) {
                for (String file : files) {
                    addMember(sb, file);
                }
            }

            void addName(StringBuilder sb, String key) {
                sb.append("        <name>").append(xmlMap.get(key)).append("</name>\n");
            }

            void addTypes(StringBuilder sb, String key, TreeSet files) {
                sb.append("    <types>\n");
                
                addMembers(sb, files);
                addName(sb, key);

                sb.append("    </types>\n");
            }

            boolean addField(StringBuilder sb, String[] field) {
                if (null == field) {
                    System.out.println("WARNING:  Presented a null field list - ignoring!");
                    return false;
                } else if (field.length < 2) {
                    System.out.println("WARNING:  Presented field list contains too few items - ignoring!");
                    return false;
                }

                sb.append("    <types>\n");
                sb.append("        <members>").append(field[1]).append("</members>\n");
                sb.append("        <name>").append(field[0]).append("</name>\n");

                sb.append("    </types>\n");

                return true;
            }

            void addFields(StringBuilder sb, String[] fieldList) {
                if (null == fieldList) {
                    return;
                }

                for (String field : fieldList) {
                    if (!addField(sb, field.split("="))) {
                        System.out.println("WARNING:  The field list was ignored due to null or no equal sign:  [" + field + "]");
                    }
                }
            }

            void addFields(StringBuilder sb, String fieldList) {
                if (null == fieldList) {
                    return;
                }

                addFields(sb, fieldList.split(":"));
            }

            String computeXml(Map elementMap, String fieldList) {
                StringBuilder sb = new StringBuilder();

                sb.append("<package xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n");

                for (String key : elementMap.keySet()) {
                    addTypes(sb, key, elementMap.get(key));
                }

                addFields(sb, fieldList);

                sb.append("    <version>").append(attributes.get("version")).append("</version>\n");
                sb.append("</package>\n");

                return sb.toString();
            }

            project.setProperty(attributes.get("property"), computeXml(computeActualElements(attributes.get("filelist").split(getFileDelimiter(attributes.get("filedelimiter")))), attributes.get("fieldlist")));
		]]>
	</scriptdef>

	<macrodef name="file-list-xml-types" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the types XML elements for the files contained in @{fileList}">
		<attribute name="property" description="Property to store the XML for types for each file liested in @{fileList}"/>
		<attribute name="fileList"    description="The files for which an XML types element will be generated"/>
		<attribute name="fileDelimiter"    default="${path.separator}" description="The delimiter used to separate file names in ${fileList}"/>
		<attribute name="members-all"      default="${sf.all}" description="If a dir is contained in @{members-all}, * will be used for all members vs each member in the list"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<!--
				Reset all possible types children.
			-->
			<rh-util:processList param="file-list-xml-types.FILE" list="@{fileList}" listDelimiter="@{fileDelimiter}">
				<rh-util:baseName property="file-list-xml-types.BASE_FILE_NAME" file="@{file-list-xml-types.FILE}"/>

				<!--
					We want to skip package.xml
				-->
				<rh-util:ifEqual arg1="package.xml" arg2="${file-list-xml-types.BASE_FILE_NAME}">
					<rh-util:then>
						<echo message="Skipping package.xml!"/>
					</rh-util:then>

					<rh-util:else>
						<!--
							Need to find the parent dir for the file.  We need this so that we can compute
							the name element.
						-->
						<rh-util:dirName  property="file-list-xml-types.DIR"      file="@{file-list-xml-types.FILE}"/> 
						<rh-util:baseName property="file-list-xml-types.DIR-NAME" file="${file-list-xml-types.DIR}"/> 

						<rh-util:property name="file-list-xml-types.MEMBERS-PREFIX" value=""/>

						<!--
							If file-list-xml-types.DIR-NAME is found in the property sf.dirs, we have the "correct" containing
							dir.  Otherwise, get the parent dir again.  We should be, at most, 2 dirs deep (assuming the file
							is a folder based file...
						-->
						<rh-util:ifNotContains string="${sf.dirs}" substring="${file-list-xml-types.DIR-NAME}">
							<rh-util:then>
								<!--
									If this is file is folder based, we need the parent dir's name as the
									prefix...
								-->
								<rh-util:property name="file-list-xml-types.MEMBERS-PREFIX" value="${file-list-xml-types.DIR-NAME}/"/>

								<!--
									Look at the parent dir - will need to see if it is in sf.dirs
								-->
								<rh-util:dirName  property="file-list-xml-types.DIR"      file="${file-list-xml-types.DIR}"/> 
								<rh-util:baseName property="file-list-xml-types.DIR-NAME" file="${file-list-xml-types.DIR}"/> 

								<!--
									Make sure this directory is found in sf.dirs.  If not, we will fail as there is nothing
									we can do for processing this file...
								-->
								<rh-util:ifNotContains string="${sf.dirs}" substring="${file-list-xml-types.DIR-NAME}">
									<rh-util:then>
										<echo message="WARNING:  Cannot process @{file-list-xml-types.FILE}.  One of the parent directories, ${file-list-xml-types.DIR-NAME}, is not included in ${sf.dirs}"/>
										<!--
										<fail message="Cannot process @{file-list-xml-types.FILE}.  One of the parent directories, ${file-list-xml-types.DIR-NAME}, is not included in ${sf.dirs}"/>
										-->
									</rh-util:then>
								</rh-util:ifNotContains>
							</rh-util:then>
						</rh-util:ifNotContains>

						<rh-util:property name="file-list-xml-types.TYPES_MEMBERS.${file-list-xml-types.DIR-NAME}" value=""/>
					</rh-util:else>
				</rh-util:ifEqual>
			</rh-util:processList>

			<rh-util:property name="file-list-xml-types.TYPES_MEMBERS" value="" description="This will hold all members dirs"/>

			<!--
				Iterate through setting up the members elements for a dir...
			-->
			<rh-util:processList param="file-list-xml-types.FILE" list="@{fileList}" listDelimiter="@{fileDelimiter}">
				<!--
					Need to find the parent dir for the file.  We need this so that we can compute
					the name element.
				-->
				<rh-util:dirName  property="file-list-xml-types.DIR"      file="@{file-list-xml-types.FILE}"/> 
				<rh-util:baseName property="file-list-xml-types.DIR-NAME" file="${file-list-xml-types.DIR}"/> 

				<rh-util:property name="file-list-xml-types.MEMBERS-PREFIX" value=""/>

				<!--
					If file-list-xml-types.DIR-NAME is found in the property sf.dirs, we have the "correct" containing
					dir.  Otherwise, get the parent dir again.  We should be, at most, 2 dirs deep (assuming the file
					is a folder based file...
				-->
				<rh-util:ifNotContains string="${sf.dirs}" substring="${file-list-xml-types.DIR-NAME}">
					<rh-util:then>
						<!--
							If this is file is folder based, we need the parent dir's name as the
							prefix...
						-->
						<rh-util:property name="file-list-xml-types.MEMBERS-PREFIX" value="${file-list-xml-types.DIR-NAME}/"/>

						<!--
							Look at the parent dir - will need to see if it is in sf.dirs
						-->
						<rh-util:dirName  property="file-list-xml-types.DIR"      file="${file-list-xml-types.DIR}"/> 
						<rh-util:baseName property="file-list-xml-types.DIR-NAME" file="${file-list-xml-types.DIR}"/> 
					</rh-util:then>
				</rh-util:ifNotContains>

				<!--
					Build up the members...
				-->
				<rh-util:propertyDereference name="file-list-xml-types.SUFFIX-LIST" property="sf.suffix.${file-list-xml-types.DIR-NAME}"/>
				<rh-util:baseName-List property="file-list-xml-types.BASE-NAME" file="@{file-list-xml-types.FILE}" suffixList="${file-list-xml-types.SUFFIX-LIST}"/> 
				<rh-sfdc:xml-members property="file-list-xml-types.TYPES_MEMBERS.${file-list-xml-types.DIR-NAME}" value="${file-list-xml-types.MEMBERS-PREFIX}${file-list-xml-types.BASE-NAME}" elementDelimiter="@{elementDelimiter}"/>

				<!--
					Is the directory already denoted?  We only want the directory as a type member once...
				-->
				<rh-util:ifNotContains string="${file-list-xml-types.TYPES_MEMBERS}" substring="${file-list-xml-types.DIR-NAME}">
					<rh-util:then>
						<rh-util:appendProperty name="file-list-xml-types.TYPES_MEMBERS" value="@{fileDelimiter}${file-list-xml-types.DIR-NAME}"/>
					</rh-util:then>
				</rh-util:ifNotContains>
			</rh-util:processList>

			<!--
				Iterate over the directories to process
			-->
			<rh-util:processList param="file-list-xml-types.MEMBERS" list="${file-list-xml-types.TYPES_MEMBERS}" listDelimiter="@{fileDelimiter}">
				<rh-util:propertyDereference name="file-list-xml-types.MEMBER-APPEND" property="file-list-xml-types.TYPES_MEMBERS.${file-list-xml-types.DIR-NAME}"/>
				<rh-util:propertyDereference name="file-list-xml-types.MEMBERS-NAME" property="sf.metadata.@{file-list-xml-types.MEMBERS}"/>

				<rh-sfdc:xml-types property="@{property}" name="${file-list-xml-types.MEMBERS-NAME}" elementDelimiter="@{elementDelimiter}">
					<rh-util:ifContains string="@{members-all}" substring="@{file-list-xml-types.MEMBERS}">
						<rh-util:then>
							<rh-sfdc:xml-members property="@{property}" value="*" elementDelimiter="@{elementDelimiter}"/>
						</rh-util:then>

						<rh-util:else>
							<rh-util:appendProperty name="@{property}" value="${file-list-xml-types.MEMBER-APPEND}@{elementDelimiter}"/>
						</rh-util:else>
					</rh-util:ifContains>
				</rh-sfdc:xml-types>
			</rh-util:processList>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="nonfolders-members-xml-types" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the types XML element - for non-folder based members">
		<attribute name="property" description="Property to store the XML for types where members are the wildcard"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<!--
				Iterate over all non folder based dirs, creating the types element...
			-->
			<rh-util:processPropertyAsList property="sf.dirs.nonFolderBased" param="nonfolders-members-xml-types.MEMBER">
				<rh-sfdc:xml-types property="@{property}" name="${sf.metadata.@{nonfolders-members-xml-types.MEMBER}}" elementDelimiter="@{elementDelimiter}">
					<rh-sfdc:xml-members property="@{property}" value="*" elementDelimiter="@{elementDelimiter}"/>
				</rh-sfdc:xml-types>
			</rh-util:processPropertyAsList>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="folders-members-xml-types" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate the types XML element - for folder based members of @{env}">
		<attribute name="property" description="Property to store the XML for types where members are the wildcard"/>
		<attribute name="env"      description="The name of the environment for which a vanilla folder based package.xml will be built"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>
		<attribute name="description"      default="" description="A textual description of why this macrodef is being called"/>

		<sequential>
			<fail unless="solenopsis.env.@{env}.HOME" message="UNKNOWN ENVIRONMENT:  @{env}"/>

			<!--
				Iterate over all folder based directory names...
			-->
			<ac:for param="folders-members-xml-types.DIR">
				<dirset dir="${solenopsis.env.@{env}.HOME}" includes="${sf.dirs.folderBased}"/>

				<sequential>
					<rh-util:baseName property="folders-members-xml-types.FOLDER-BASED-MEMBER" file="@{folders-members-xml-types.DIR}"/>

					<!--
						Not assuming anything.  The includes need to be set - no defaults
						will be defined!!!
					-->
					<fail unless="sf.includes.${folders-members-xml-types.FOLDER-BASED-MEMBER}" message="MISSING INCLUDES:  sf.includes.${folders-members-xml-types.FOLDER-BASED-MEMBER}"/>

					<!--
						The metadata name must be defined!!!
					-->
					<fail unless="sf.metadata.${folders-members-xml-types.FOLDER-BASED-MEMBER}" message="MISSING METADATA NAME:  sf.metadata.${folders-members-xml-types.FOLDER-BASED-MEMBER}"/>

					<rh-util:propertyDereference name="folders-members-xml-types.MEMBERS-NAME" property="sf.metadata.${folders-members-xml-types.FOLDER-BASED-MEMBER}"/>

					<rh-sfdc:xml-types property="@{property}" name="${folders-members-xml-types.MEMBERS-NAME}" elementDelimiter="@{elementDelimiter}">
						<rh-util:propertyDereference name="folders-members-xml-types.INCLUDES" property="sf.includes.${folders-members-xml-types.FOLDER-BASED-MEMBER}"/>

						<!--
							For each folder based dir found, process all the files in that dir (as denoted by the includes property)...
						-->
						<ac:for param="folders-members-xml-types.FILE">
							<fileset dir="@{folders-members-xml-types.DIR}" includes="${folders-members-xml-types.INCLUDES}"/>

							<sequential>
								<rh-util:dirName property="folders-members-xml-types.PARENT-DIR"  file="@{folders-members-xml-types.FILE}"/>

								<!--
									When processing files in the "root" dir, no prefix is needed.  However, if there
									are child directories, the "parent dir" is used as the prefix.
								-->
								<rh-util:ifEqual arg1="@{folders-members-xml-types.DIR}" arg2="${folders-members-xml-types.PARENT-DIR}">
									<rh-util:then>
										<rh-util:property name="folders-members-xml-types.MEMBER-PREFIX" value=""/>
									</rh-util:then>

									<rh-util:else>
										<rh-util:baseName property="folders-members-xml-types.BASE-NAME" file="${folders-members-xml-types.PARENT-DIR}"/>
										<rh-util:property name="folders-members-xml-types.MEMBER-PREFIX" value="${folders-members-xml-types.BASE-NAME}/"/>
									</rh-util:else>
								</rh-util:ifEqual>

								<rh-util:baseName property="folders-members-xml-types.MEMBERS-VALUE" file="@{folders-members-xml-types.FILE}"/>

								<!--
									Blindly iterate over all the suffixes and remove them (if they are defined)...
								-->
								<rh-util:processPropertyAsList property="sf.suffix.${folders-members-xml-types.FOLDER-BASED-MEMBER}" param="folders-members-xml-types.SUFFIX">
									<rh-util:baseName property="folders-members-xml-types.MEMBERS-VALUE" file="${folders-members-xml-types.MEMBERS-VALUE}" suffix="@{folders-members-xml-types.SUFFIX}"/>
								</rh-util:processPropertyAsList>

								<rh-sfdc:xml-members property="@{property}" value="${folders-members-xml-types.MEMBER-PREFIX}${folders-members-xml-types.MEMBERS-VALUE}" elementDelimiter="@{elementDelimiter}"/>
							</sequential>
						</ac:for>

					</rh-sfdc:xml-types>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="load-env-values" backtrace="true" uri="http://www.redhat.com/sfdc" description="Load the values for an env">
        <attribute name="env"           description="The dependent environment to pull from"/>
		<attribute name="failIfMissing" default="true" description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"   default=""     description="Comment regarding calling this macrodef"/>

		<sequential>
            <!--
                Fail when no credentials found (hopefully stops one from removing any
                local versions of environments - i.e. Git)...
            -->
            <ac:if>
                    <and>
                        <not>
                                <available file="${solenopsis.credentials.HOME}/@{env}.properties"/>
                        </not>
                        <not>
                                <isset property="solenopsis.USER"/>
                        </not>
                        <not>
                                <isset property="solenopsis.PASSWORD"/>
                        </not>
                        <not>
                                <isset property="solenopsis.TOKEN"/>
                        </not>

                        <equals arg1="@{failIfMissing}" arg2="true"/>
                    </and>

                <ac:then>
                    <fail message="MISSING CREDENTIALS:  @{env}  (${solenopsis.credentials.HOME}/@{env}.properties) or overridden properties solenopsis.USER / solenopsis.PASSWORD / solenopsis.TOKEN"/>
                </ac:then>
            </ac:if>

            <property file="${solenopsis.credentials.HOME}/@{env}.properties" prefix="solenopsis.env.@{env}.credentials"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="compute-env-version" backtrace="true" uri="http://www.redhat.com/sfdc" description="Compute version for an environment">
        <attribute name="env"             description="The dependent environment to pull from"/>
        <attribute name="version"         description="The property name to store the version"/>
		<attribute name="loadCredentials" default="true" description="If true, try to load the credentials into properties"/>
		<attribute name="failIfMissing"   default="true" description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"     default=""     description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:ifEqual arg1="@{loadCredentials}" arg2="true">
				<rh-util:then>
					<rh-sfdc:load-env-values env="@{env}" failIfMissing="@{failIfMissing}"/> 
				</rh-util:then>
			</rh-util:ifEqual>

			<!--
				Is version set?
			-->
            <rh-util:ifSet property="solenopsis.env.@{env}.credentials.version">
                <rh-util:then>
                    <rh-util:property name="@{version}" value="${solenopsis.env.@{env}.credentials.version}"/>
                </rh-util:then>

				<!--
					Nope is the global set?
				-->
                <rh-util:else>
					<rh-util:ifSet property="sf.version">
						<rh-util:then>
							<rh-util:property name="@{version}" value="${sf.version}"/>
						</rh-util:then>

						<rh-util:else>
							<ac:var name="@{version}" unset="true"/>
						</rh-util:else>
					</rh-util:ifSet>
                </rh-util:else>
            </rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="compute-env-multiPull" backtrace="true" uri="http://www.redhat.com/sfdc" description="Compute multipull for an environment">
        <attribute name="env"             description="The dependent environment to pull from"/>
        <attribute name="multi-pull"      description="The property name to store the multipull"/>
		<attribute name="loadCredentials" default="true" description="If true, try to load the credentials into properties"/>
		<attribute name="failIfMissing"   default="true" description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"     default=""     description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:ifEqual arg1="@{loadCredentials}" arg2="true">
				<rh-util:then>
					<rh-sfdc:load-env-values env="@{env}" failIfMissing="@{failIfMissing}"/> 
				</rh-util:then>
			</rh-util:ifEqual>

			<!--
				Is multi-pull set?
			-->
            <rh-util:ifSet property="solenopsis.env.@{env}.credentials.multiPull">
                <rh-util:then>
                    <rh-util:property name="@{multi-pull}" value="${solenopsis.env.@{env}.credentials.multiPull}"/>
                </rh-util:then>

				<!--
					Nope is the global set?
				-->
                <rh-util:else>
					<rh-util:ifSet property="sf.multiPull">
						<rh-util:then>
							<rh-util:property name="@{multi-pull}" value="${sf.multiPull}"/>
						</rh-util:then>

						<rh-util:else>
							<ac:var name="@{multi-pull}" unset="true"/>
						</rh-util:else>
					</rh-util:ifSet>
                </rh-util:else>
            </rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="compute-env-url" backtrace="true" uri="http://www.redhat.com/sfdc" description="Compute url for an environment">
        <attribute name="env"             description="The dependent environment to pull from"/>
        <attribute name="url"             description="The property name to store the url"/>
		<attribute name="loadCredentials" default="true" description="If true, try to load the credentials into properties"/>
		<attribute name="failIfMissing"   default="true" description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"     default=""     description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:ifEqual arg1="@{loadCredentials}" arg2="true">
				<rh-util:then>
					<rh-sfdc:load-env-values env="@{env}" failIfMissing="@{failIfMissing}"/> 
				</rh-util:then>
			</rh-util:ifEqual>

			<!--
				Is the URL set?
			-->
            <rh-util:ifSet property="solenopsis.env.@{env}.credentials.url">
                <rh-util:then>
                    <rh-util:property name="@{url}" value="${solenopsis.env.@{env}.credentials.url}"/>
                </rh-util:then>

                <rh-util:else>
                    <rh-util:property name="@{url}" value="${sf.url.SANDBOX}"/>
                </rh-util:else>
            </rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="compute-env-generateTests" backtrace="true" uri="http://www.redhat.com/sfdc" description="Compute generateTests for an environment">
        <attribute name="env"             description="The dependent environment to pull from"/>
        <attribute name="generate-tests"  description="The property name to store the multipull"/>
		<attribute name="loadCredentials" default="true" description="If true, try to load the credentials into properties"/>
		<attribute name="failIfMissing"   default="true" description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"     default=""     description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:ifEqual arg1="@{loadCredentials}" arg2="true">
				<rh-util:then>
					<rh-sfdc:load-env-values env="@{env}" failIfMissing="@{failIfMissing}"/> 
				</rh-util:then>
			</rh-util:ifEqual>

			<!--
				Is generate-tests set?
			-->
            <rh-util:ifSet property="solenopsis.env.@{env}.credentials.generateTests">
                <rh-util:then>
					<rh-util:property name="@{generate-tests}" value="${solenopsis.env.@{env}.credentials.generateTests}"/>
                </rh-util:then>

				<!--
					Nope is the global set?
				-->
                <rh-util:else>
					<rh-util:ifSet property="sf.generateTests">
						<rh-util:then>
							<rh-util:property name="@{generate-tests}" value="${sf.generateTests}"/>
						</rh-util:then>

						<rh-util:else>
							<ac:var name="@{generate-tests}" unset="true"/>
						</rh-util:else>
					</rh-util:ifSet>
                </rh-util:else>
            </rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <macrodef name="compute-env-values" backtrace="true" uri="http://www.redhat.com/sfdc" description="Set the credentials for an environment">
        <attribute name="env"                description="The dependent environment to pull from"/>
        <attribute name="username"           description="The property name to store the user name"/>
		<attribute name="webServicePassword" description="The property name to store the web password - password plus token"/>
        <attribute name="version"            description="The property name to store the url"/>
        <attribute name="url"                description="The property name to store the url"/>
        <attribute name="password"           default="compute-env-values.PASSWORD"       description="The property name to store the password"/>
        <attribute name="token"              default="compute-env-values.TOKEN"          description="The property name to store the token"/>
        <attribute name="multi-pull"         default="compute-env-values.MULTI_PART"     description="The property name to store multi-pull values"/>
		<attribute name="generate-tests"     default="compute-env-values.GENERATE_TESTS" description="The property name to store generate-tests"/>
		<attribute name="failIfMissing"      default="true"                              description="If true, will fail if the credentials else ignore"/>
        <attribute name="description"        default=""                                  description="Comment regarding calling this macrodef"/>

        <sequential>
			<rh-sfdc:load-env-values env="@{env}" failIfMissing="@{failIfMissing}"/> 

            <rh-util:ifSet property="solenopsis.USER">
                <rh-util:then>
                    <rh-util:property name="compute-env-values.USER" value="${solenopsis.USER}"/>
                    <echo message="**** User is overridden to [${solenopsis.USER}]"/>
                </rh-util:then>

                <rh-util:else>
                    <rh-util:property name="compute-env-values.USER" value="${solenopsis.env.@{env}.credentials.username}"/>
                </rh-util:else>
            </rh-util:ifSet>

            <rh-util:ifSet property="solenopsis.PASSWORD">
                <rh-util:then>
                    <rh-util:property name="compute-env-values.PASSWORD" value="${solenopsis.PASSWORD}"/>
                    <echo message="**** Password is overridden..."/>
                </rh-util:then>

                <rh-util:else>
                    <rh-util:property name="compute-env-values.PASSWORD" value="${solenopsis.env.@{env}.credentials.password}"/>
                </rh-util:else>
            </rh-util:ifSet>

            <rh-util:ifSet property="solenopsis.TOKEN">
                <rh-util:then>
                    <rh-util:property name="compute-env-values.TOKEN" value="${solenopsis.TOKEN}"/>
                    <echo message="**** Token is overridden..."/>
                </rh-util:then>

                <rh-util:else>
                    <rh-util:property name="compute-env-values.TOKEN" value="${solenopsis.env.@{env}.credentials.token}"/>
                </rh-util:else>
            </rh-util:ifSet>


            <rh-util:property name="@{username}"           value="${compute-env-values.USER}"/>
            <rh-util:property name="@{webServicePassword}" value="${compute-env-values.PASSWORD}${compute-env-values.TOKEN}"/>
			<rh-util:property name="@{password}"           value="${compute-env-values.PASSWORD}"/>
            <rh-util:property name="@{token}"              value="${compute-env-values.TOKEN}"/>

			<rh-sfdc:compute-env-version       env="@{env}" version="@{version}"               loadCredentials="false"/>
			<rh-sfdc:compute-env-url           env="@{env}" url="@{url}"                       loadCredentials="false"/>
			<rh-sfdc:compute-env-multiPull     env="@{env}" multi-pull="@{multi-pull}"         loadCredentials="false"/>
			<rh-sfdc:compute-env-generateTests env="@{env}" generate-tests="@{generate-tests}" loadCredentials="false"/>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="compute-all-env-values" backtrace="true" uri="http://www.redhat.com/sfdc" description="Compute all the environment values">
		<attribute name="property" description="Compute all the environment values and store in property entitled property"/>

		<sequential>
			<ac:var name="compute-all-env-values.VALUE" unset="true"/>

			<rh-util:processList param="compute-all-env-values.ENV" list="${solenopsis.ENVIRONMENTS}" listDelimiter=" ">
				<rh-sfdc:compute-env-values env="@{compute-all-env-values.ENV}" username="compute-all-env-values.@{compute-all-env-values.ENV}.USERNAME"
					webServicePassword="compute-all-env-values.@{compute-all-env-values.ENV}.WEB_SERVICE_PASSWORD" version="compute-all-env-values.@{compute-all-env-values.ENV}.VERSION"
					url="compute-all-env-values.@{compute-all-env-values.ENV}.URL" password="compute-all-env-values.@{compute-all-env-values.ENV}.PASSWORD"
					token="compute-all-env-values.@{compute-all-env-values.ENV}.TOKEN" multi-pull="compute-all-env-values.@{compute-all-env-values.ENV}.MULTI_PULL"
					generate-tests="compute-all-env-values.@{compute-all-env-values.ENV}.GENERATE_TESTS" failIfMissing="false"/>

				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="@{compute-all-env-values.ENV}:${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    user name:             ${compute-all-env-values.@{compute-all-env-values.ENV}.USERNAME}${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    web service password:  ${compute-all-env-values.@{compute-all-env-values.ENV}.WEB_SERVICE_PASSWORD}${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    version:               ${compute-all-env-values.@{compute-all-env-values.ENV}.VERSION}${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    url:                   ${compute-all-env-values.@{compute-all-env-values.ENV}.URL}${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    password:              ${compute-all-env-values.@{compute-all-env-values.ENV}.PASSWORD}${line.separator}"/>
				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    token:                 ${compute-all-env-values.@{compute-all-env-values.ENV}.TOKEN}${line.separator}"/>

				<rh-util:ifSet property="compute-all-env-values.@{compute-all-env-values.ENV}.MULTI_PULL">
					<rh-util:then>
						<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    multiPull:             ${compute-all-env-values.@{compute-all-env-values.ENV}.MULTI_PULL}${line.separator}"/>
					</rh-util:then>
					<rh-util:else>
						<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    multiPull:             ** NOT DEFINED **${line.separator}"/>
					</rh-util:else>
				</rh-util:ifSet>

				<rh-util:ifSet property="compute-all-env-values.@{compute-all-env-values.ENV}.GENERATE_TESTS">
					<rh-util:then>
						<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    generateTests:         ${compute-all-env-values.@{compute-all-env-values.ENV}.GENERATE_TESTS}${line.separator}"/>
					</rh-util:then>
					<rh-util:else>
						<rh-util:appendProperty name="compute-all-env-values.VALUE" value="    generateTests:         ** NOT DEFINED **${line.separator}"/>
					</rh-util:else>
				</rh-util:ifSet>

				<rh-util:appendProperty name="compute-all-env-values.VALUE" value="${line.separator}"/>
			</rh-util:processList>

			<ac:var name="@{property}" value="${compute-all-env-values.VALUE}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="generate-package" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will generate a package (non-folder based)">
		<attribute name="dir"          default=""              description="The directory in which to generate the package.xml"/>
		<attribute name="version"      default="${sf.version}" description="The version to generate"/>
		<attribute name="description"  default=""              description="Comment regarding calling this macrodef"/>

		<sequential>
			<!--
				Compute dir to emit package.xml...
			-->
			<rh-util:ifEqual arg1="@{dir}" arg2="">
				<rh-util:then>
					<rh-util:ifSet property="sf.packageDir">
						<rh-util:then>
							<rh-util:property name="sfdc-util.generate-package.DIR" value="${sf.packageDir}"/>
						</rh-util:then>

						<rh-util:else>
							<rh-util:property name="sfdc-util.generate-package.DIR" value="${user.dir}"/>
						</rh-util:else>
					</rh-util:ifSet>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="sfdc-util.generate-package.DIR" value="@{dir}"/>
				</rh-util:else>
			</rh-util:ifEqual>

			<!--
				Generate the package.
			-->
			<rh-sfdc:xml-package property="sfdc-util.generate-package.PACKAGE" version="@{version}">
				<rh-sfdc:members-xml-types property="sfdc-util.generate-package.PACKAGE"/>
				<rh-sfdc:nonfolders-members-xml-types property="sfdc-util.generate-package.PACKAGE"/>
			</rh-sfdc:xml-package>

			<!--
				Generate dir and emit package.xml...
			-->
			<mkdir dir="${sfdc-util.generate-package.DIR}"/>
			<echo message="${sfdc-util.generate-package.PACKAGE}" file="${sfdc-util.generate-package.DIR}/package.xml"/>

			<echo message="Generated ${sfdc-util.generate-package.DIR}/package.xml"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="generate-full-package" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will generate a package (folder based upon master)">
		<attribute name="masterEnv"    default="${solenopsis.env.MASTER}" description="The directory in which to generate the package.xml"/>
		<attribute name="dir"          default=""                         description="The directory in which to generate the package.xml"/>
		<attribute name="version"      default="${sf.version}"            description="The version to generate"/>
		<attribute name="description"  default=""                         description="Comment regarding calling this macrodef"/>

		<sequential>
			<!--
				Compute dir to emit package.xml...
			-->
			<rh-util:ifEqual arg1="@{dir}" arg2="">
				<rh-util:then>
					<rh-util:ifSet property="sf.packageDir">
						<rh-util:then>
							<rh-util:property name="sfdc-util.generate-full-package.DIR" value="${sf.packageDir}"/>
						</rh-util:then>

						<rh-util:else>
							<rh-util:property name="sfdc-util.generate-full-package.DIR" value="${user.dir}"/>
						</rh-util:else>
					</rh-util:ifSet>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="sfdc-util.generate-full-package.DIR" value="@{dir}"/>
				</rh-util:else>
			</rh-util:ifEqual>

			<!--
				Generate the package.
			-->
			<rh-sfdc:xml-package property="sfdc-util.generate-full-package.PACKAGE" version="@{version}">
				<rh-sfdc:members-xml-types property="sfdc-util.generate-full-package.PACKAGE"/>
				<rh-sfdc:nonfolders-members-xml-types property="sfdc-util.generate-full-package.PACKAGE"/>

				<rh-sfdc:folders-members-xml-types property="sfdc-util.generate-full-package.PACKAGE" env="@{masterEnv}"/>
			</rh-sfdc:xml-package>

			<!--
				Generate dir and emit package.xml...
			-->
			<mkdir dir="${sfdc-util.generate-full-package.DIR}"/>
			<echo message="${sfdc-util.generate-full-package.PACKAGE}" file="${sfdc-util.generate-full-package.DIR}/package.xml"/>

			<echo message="Generated ${sfdc-util.generate-full-package.DIR}/package.xml"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="computeIgnoreXslt" uri="http://www.redhat.com/sfdc" language="beanshell" description="Computes the XSLT to apply using the sfdcignore file">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="path"/>
        <attribute name="xslt"/>
        <attribute name="property"/>

		<![CDATA[
            String lineSeparator            = System.getProperty("line.separator") + "\t";
            String pathSeparator            = System.getProperty("path.separator");
            String fileSeparator            = System.getProperty("file.separator");

            String containsLayouts          = fileSeparator + "layouts" + fileSeparator;
            String containsClasses          = fileSeparator + "classes" + fileSeparator;

            String templatePrefixSnippet    = "<xsl:template mode=\"copy-children\" match=\"sfdc:";
            String templateLayoutsSnippet   = "layoutAssignments [sfdc:layout";
            String templateClassesSnippet   = "classAccesses [sfdc:apexClass";
            String templateConditionSnippet = " [normalize-space(text()) = '";
            String templatePostfixSnippet   = "']]\"/>";

            String templateLayoutPrefix     = templatePrefixSnippet + templateLayoutsSnippet + templateConditionSnippet;
            String templateClassesPrefix    = templatePrefixSnippet + templateClassesSnippet + templateConditionSnippet;

            boolean isLayoutsFileName(String fileName) {
                return fileName.contains(containsLayouts);
            }

            boolean isClassFile(String fileName) {
                return fileName.contains(containsClasses) && !fileName.endsWith("meta.xml");
            }

            boolean isIncludeFile(String fileName) {
                return isLayoutsFileName(fileName) || isClassFile(fileName);
            }

            String[] convertPathToArray(String path) {
                return path.split(pathSeparator);
            }

            String getBaseFilename(File file) {
                return file.getName().substring(0, file.getName().lastIndexOf("."));
            }

            String getBaseFilename(String fileName) {
                return getBaseFilename(new File(fileName));
            }

            void addFile(List fileList, String rawFilename) {
                if (!isIncludeFile(rawFilename)) {
                    return;
                }

                fileList.add(getBaseFilename(rawFilename));
            }

            List computeFiles(String path) {
                List retVal = new ArrayList();

                for (String file : convertPathToArray(path)) {
                    addFile(retVal, file);
                }

                return retVal;
            }

            void addTemplate(StringBuilder sb, String templatePrefix, String fileName) {
                sb.append(templatePrefix).append(fileName).append(templatePostfixSnippet).append(lineSeparator);
            }

            void addLayoutTemplate(StringBuilder sb, String fileName) {
                addTemplate(sb, templateLayoutPrefix, fileName);
            }

            void addClassesTemplate(StringBuilder sb, String fileName) {
                addTemplate(sb, templateClassesPrefix, fileName);
            }

            void addIgnoreTemplates(StringBuilder sb, String fileName) {
                addLayoutTemplate(sb, fileName);
                addClassesTemplate(sb, fileName);
            }

            String getIgnoreTemplates(List files) {
                StringBuilder sb = new StringBuilder();

                for (String file : files) {
                    addIgnoreTemplates(sb, file);
                }

                return sb.toString();
            }

            String replaceTokens(String template, String toReplace) {
                return template.replaceAll("@@IGNORE@@", toReplace);
            }

            List ignoreFiles = computeFiles(attributes.get("path"));

            project.setProperty(attributes.get("property"), replaceTokens(attributes.get("xslt"), getIgnoreTemplates(ignoreFiles)));;
		]]>
	</scriptdef>

    <macrodef name="purge-ignores-refs" backtrace="true" uri="http://www.redhat.com/sfdc" description="Ensure the references contained in an ignore file are ignored">
        <attribute name="env"                                       description="The directory in which to purge references to the ignores"/>
		<attribute name="ignoreFile"   default="${sf.ignoreFile}"   description="A file containing patterns/file names of what to exclude"/>
        <attribute name="purgeIgnores" default="${sf.purgeIgnores}" description="If anything but false, will allow this processing to proceed"/>
		<attribute name="description"  default=""                   description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:ifNotEqual arg1="@{purgeIgnores}" arg2="false">
				<rh-util:then>
                    <rh-util:ifNotEqual arg1="" arg2="@{ignoreFile}">
                        <rh-util:then>
                            <rh-util:property name="purge-ignores-refs.DIR" value="${solenopsis.env.@{env}.HOME}"/>
                            <rh-util:assertFileExists file="${purge-ignores-refs.DIR}"/>

                            <rh-util:property name="purge-ignores-refs.tmp.DIR" value="${solenopsis.temp.DIR}/purge-ignores-refs"/>
                            <delete dir="${purge-ignores-refs.tmp.DIR}"/>
                            <mkdir dir="${purge-ignores-refs.tmp.DIR}"/>

                            <rh-util:property name="purge-ignores-refs.tmp.XSLT" value="${purge-ignores-refs.tmp.DIR}/sfdcignore.xsl"/>

                            <echo>
                                Processing:      [@{env}]
                                Jar:             [${sf.migrationToolJar}]
                                Dir:             [${purge-ignores-refs.DIR}]
                                Ignore File:     [@{ignoreFile}]

                                Temp Dir:        [${purge-ignores-refs.tmp.DIR}]
                                Generated XSLT:  [${purge-ignores-refs.tmp.XSLT}]
                                Transforms:      
                            </echo>

                            <rh-util:assertFileExists file="@{ignoreFile}"/>

                            <pathconvert property="purge-ignores-refs.PATH">
                                <fileset dir="${purge-ignores-refs.DIR}" includesfile="@{ignoreFile}"/>
                            </pathconvert>

                            <loadfile property="purge-ignore-refs.XSL_TEMPLATE" srcFile="${solenopsis.HOME}/../../xsl/templates/sfdcignore-template.xsl"/>

                            <rh-sfdc:computeIgnoreXslt path="${purge-ignores-refs.PATH}" xslt="${purge-ignore-refs.XSL_TEMPLATE}" property="purge-ignores-refs.XSLT"/>
                            <echo message="${purge-ignores-refs.XSLT}" file="${purge-ignores-refs.tmp.XSLT}"/>

                            <xslt style="${purge-ignores-refs.tmp.XSLT}" extension=".profile" basedir="${purge-ignores-refs.DIR}/profiles" destdir="${purge-ignores-refs.tmp.DIR}/profiles"/>
                            <xslt style="${purge-ignores-refs.tmp.XSLT}" extension=".permissionset" basedir="${purge-ignores-refs.DIR}/permissionsets" destdir="${purge-ignores-refs.tmp.DIR}/permissionsets"/>

                            <copy todir="${purge-ignores-refs.DIR}/profiles">
                                <fileset dir="${purge-ignores-refs.tmp.DIR}/profiles"/>
                            </copy>

                            <copy todir="${purge-ignores-refs.DIR}/permissionsets">
                                <fileset dir="${purge-ignores-refs.tmp.DIR}/permissionsets"/>
                            </copy>
                        </rh-util:then>

                        <rh-util:else>
                            <echo message="No ignore file presented - skipping!"/>
                        </rh-util:else>
                    </rh-util:ifNotEqual>
                </rh-util:then>

                <rh-util:else>
                    <echo>
                        Purging ignores is set to [@{purgeIgnores}] - therefore it is skipped!

                        If you want it enabled, ensure the value is not [@{purgeIgnores}].  This
                        can be done by defining the environment variable sf.purgeIgnores to true
                        or any other value.
                    </echo>
                </rh-util:else>
            </rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="cleanIgnoreFile" uri="http://www.redhat.com/sfdc" language="beanshell" description="Do the actual cleaning">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="ignoreFile"/>

		<![CDATA[
            File ignoreFile = new File(attributes.get("ignorefile"));

            byte[] rawFile = new byte[(int) ignoreFile.length()];

            RandomAccessFile rafIn = new RandomAccessFile(ignoreFile, "r");

            rafIn.readFully(rawFile);
            rafIn.close();

            StringBuilder sb = new StringBuilder();

            BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(rawFile)));

            String line = null;

            while ((line = br.readLine()) != null) {
                sb.append(line.trim()).append("\n");
            }

            br.close();

            RandomAccessFile rafOut = new RandomAccessFile(ignoreFile, "rw");

            rafOut.writeBytes(sb.toString());
            rafOut.close();
		]]>
	</scriptdef>

    <macrodef name="clean-ignore-file" backtrace="true" uri="http://www.redhat.com/sfdc" description="Clean the ignore file of things like trailing spaces">
		<attribute name="ignoreFile"   default="${sf.ignoreFile}"   description="A file containing patterns/file names of what to exclude"/>
		<attribute name="description"  default=""                   description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-util:ifNotEqual arg1="" arg2="@{ignoreFile}">
                <rh-util:then>
                    <rh-util:assertFileExists file="@{ignoreFile}"/>

                    <echo>
                        Cleaning:  [@{ignoreFile}]
                    </echo>

                    <rh-sfdc:cleanIgnoreFile ignoreFile="@{ignoreFile}"/>
                </rh-util:then>

                <rh-util:else>
                    <echo>
                        No ignore file presented - ignoring!
                    </echo>
                </rh-util:else>
            </rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="generateBulkRetrieveXml" uri="http://www.redhat.com/sfdc" language="beanshell" description="Generate a build.xml for a build retrieve">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="dir"/>
        <attribute name="antJar"/>
        <attribute name="username"/>
        <attribute name="password"/>
        <attribute name="serverurl"/>
        <attribute name="maxPoll"/>
        <attribute name="metadataType"/>
        <attribute name="retrieveTarget"/>
        <attribute name="batchSize"/>
        <attribute name="apiVersion"/>
        <attribute name="dumpFiles"/>
        <attribute name="showPasswords"/>

		<![CDATA[
            StringBuilder appendAttribute(StringBuilder sb, String name, String value) {
                sb.append(' ').append(name).append("='").append(value).append("'");
                return sb;
            }

            StringBuilder generateLine(StringBuilder sb, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String metadataType, String retrieveTarget, String batchSize, String apiVersion) {
                sb.append("    <sf:bulkRetrieve");
                appendAttribute(sb, "username", username);
                    
                appendAttribute(sb, "password", isShowPassword ? password : "");

                appendAttribute(sb, "serverurl", serverurl);
                appendAttribute(sb, "maxPoll", maxPoll);
                appendAttribute(sb, "metadataType", metadataType);
                appendAttribute(sb, "retrieveTarget", retrieveTarget);
                appendAttribute(sb, "batchSize", batchSize);
                appendAttribute(sb, "apiVersion", apiVersion);
                appendAttribute(sb, "unzip", "true");

                sb.append("/>\n");

                return sb;
            }

            StringBuilder generateTaskDef(StringBuilder sb, String antJar) {
                sb.append("    <taskdef resource='com/salesforce/antlib.xml' uri='antlib:com.salesforce'>\n");
                sb.append("        <classpath>\n");
                sb.append("            <fileset");
                appendAttribute(sb, "file", antJar);
                sb.append("/>\n");
                sb.append("        </classpath>\n");
                sb.append("    </taskdef>\n\n");

                return sb;
            }

            StringBuilder generateFile(StringBuilder sb, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String metadataType, String retrieveTarget, String batchSize, String apiVersion) {
                sb.append("<project basedir='.' xmlns:sf='antlib:com.salesforce'>\n");

                generateTaskDef(sb, antJar);
                generateLine(sb, isShowPassword, username, password, serverurl, maxPoll, metadataType, retrieveTarget, batchSize, apiVersion);

                sb.append("</project>\n");

                return sb;
            }

            String generateFile(String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String metadataType, String retrieveTarget, String batchSize, String apiVersion) {
                return generateFile(new StringBuilder(), antJar, isShowPassword, username, password, serverurl, maxPoll, metadataType, retrieveTarget, batchSize, apiVersion).toString(); 
            }

            boolean isBlank(String property) {
                return null == attributes.get(property) || "".equals(attributes.get(property).trim());
            }

            void writeFile(String dir, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String metadataType, String retrieveTarget, String batchSize, String apiVersion) {
                File realDir = new File(dir);
                realDir.mkdirs();

                File realFile = new File(realDir, "build.xml");
                FileWriter realFileWriter = new FileWriter(realFile);
                realFileWriter.write(generateFile(antJar, isShowPassword, username, password, serverurl, maxPoll, metadataType, retrieveTarget, batchSize, apiVersion));
                realFileWriter.close();

            }

            void writeFile(boolean isGenerateFile, String dir, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String metadataType, String retrieveTarget, String batchSize, String apiVersion) {
                if (!isGenerateFile) {
                    return;
                }

                writeFile(dir, antJar, isShowPassword, username, password, serverurl, maxPoll, metadataType, retrieveTarget, batchSize, apiVersion);
            }

            writeFile(!isBlank("dumpfiles"), attributes.get("dir"),  attributes.get("antjar"), !isBlank("showpasswords"), attributes.get("username"), attributes.get("password"), attributes.get("serverurl"), attributes.get("maxpoll"), attributes.get("metadatatype"), attributes.get("retrievetarget"), attributes.get("batchsize"), attributes.get("apiversion"));
		]]>
	</scriptdef>

	<macrodef name="selective-pull" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - but using the types denoted in the types attribute">
		<attribute name="dependentEnv"  default="${solenopsis.env.DEPENDENT}" description="The dependent environment to pull from"/>
		<attribute name="types"         default="${sf.types}"                 description="A comma separated list of types to pull"/>
		<attribute name="ignoreFile"    default="${sf.ignoreFile}"            description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="trace"         default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"       default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="batchSize"     default="${sf.batchSize}"             description="The number of items to retrieve in multi-part retrieves"/>
        <attribute name="dumpFiles"     default="${sf.dumpFiles}"             description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords" default="${sf.showPasswords}"         description="When generating a build.xml, will contain the token/password used"/>
        <attribute name="xslDir"        default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"   default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="selective-pull.USERNAME" webServicePassword="selective-pull.PASSWORD" url="selective-pull.URL" version="selective-pull.VERSION"/>

			<rh-util:property name="selective-pull.tmp.DIR" value="${solenopsis.temp.DIR}/selective-pull"/>
			<delete dir="${selective-pull.tmp.DIR}"/>
			<mkdir dir="${selective-pull.tmp.DIR}"/>

			<rh-util:ifEqual arg1="@{types}" arg2="">
				<rh-util:then>
					<echo message="Using property selector!!!"/>
					<ac:propertyselector property="selective-pull.TYPES" delimiter="," match="sf\.metadata\.([^\.]*)" select="\0" casesensitive="false"/>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="selective-pull.TYPES" value="@{types}"/>
				</rh-util:else>
			</rh-util:ifEqual>

			<echo>

				Processing:  [@{dependentEnv}]

				URL:         [${selective-pull.URL}]
				API:         [${selective-pull.VERSION}]

				Jar:         [${sf.migrationToolJar}]

				Types:       [${selective-pull.TYPES}]

			</echo>

			<rh-util:property name="selective-pull.DIR" value="${solenopsis.env.@{dependentEnv}.HOME}"/>

			<delete dir="${selective-pull.DIR}"/>
			<mkdir  dir="${selective-pull.DIR}"/>

			<rh-util:processList param="selective-pull.TYPE" list="${selective-pull.TYPES}" listDelimiter=",">
				<rh-util:propertyDereference name="selective-pull.RAW_TYPE" property="@{selective-pull.TYPE}"/>

				<rh-util:ifSet property="@{selective-pull.TYPE}">
					<rh-util:then>
						<rh-util:property name="selective-pull.META_DATA_TYPE" value="${@{selective-pull.TYPE}}"/>
					</rh-util:then>

					<rh-util:else>
						<rh-util:property name="selective-pull.META_DATA_TYPE" value="@{selective-pull.TYPE}"/>
					</rh-util:else>
				</rh-util:ifSet>

				<ac:var name="selective-pull.EXCEPTION" unset="true"/>

                <rh-sfdc:generateBulkRetrieveXml dir="${selective-pull.tmp.DIR}" antJar="${sf.migrationToolJar}" username="${selective-pull.USERNAME}" password="${selective-pull.PASSWORD}" serverurl="${selective-pull.URL}" maxPoll="@{maxPoll}" metadataType="${selective-pull.META_DATA_TYPE}" retrieveTarget="${selective-pull.tmp.DIR}" batchSize="@{batchSize}" apiVersion="${selective-pull.VERSION}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

				<ac:trycatch property="selective-pull.EXCEPTION">
					<ac:try>
						<sf:bulkRetrieve username="${selective-pull.USERNAME}" password="${selective-pull.PASSWORD}" serverurl="${selective-pull.URL}" maxPoll="@{maxPoll}" metadataType="${selective-pull.META_DATA_TYPE}" retrieveTarget="${selective-pull.tmp.DIR}" batchSize="@{batchSize}" apiVersion="${selective-pull.VERSION}" unzip="true"/>
					</ac:try>

					<ac:catch>
						<!--
							We will only continue processing on invalid types...
						-->
						<rh-util:ifNotEqual arg1="com.sforce.ws.SoapFaultException: INVALID_TYPE: Unknown type:${selective-pull.META_DATA_TYPE}" arg2="${selective-pull.EXCEPTION}">
							<rh-util:then>
								<fail message="${selective-pull.EXCEPTION}"/>
							</rh-util:then>
						</rh-util:ifNotEqual>

						<echo message="Warning - trouble retrieving type [${selective-pull.META_DATA_TYPE}]"/>
					</ac:catch>
				</ac:trycatch>
			</rh-util:processList>

			<rh-util:property name="selective-pull.ZIP_FILE" value="${selective-pull.tmp.DIR}/selective-pull.zip"/>

			<!--
				If an excludes file is passed in, use that for the zip task, otherwise,
				just call out to zip without it.  Unfortunately, zip complains if one
				presents an empty string...
			-->
			<rh-util:ifNotEqual arg1="@{ignoreFile}" arg2="">
				<rh-util:then>
					<zip destfile="${selective-pull.ZIP_FILE}" basedir="${selective-pull.tmp.DIR}" excludesfile="@{ignoreFile}" level="9"/>
				</rh-util:then>

				<rh-util:else>
					<zip destfile="${selective-pull.ZIP_FILE}" basedir="${selective-pull.tmp.DIR}" level="9"/>
				</rh-util:else>
			</rh-util:ifNotEqual>

			<rh-util:ifFileExists file="${selective-pull.ZIP_FILE}">
				<rh-util:then>
					<unzip src="${selective-pull.ZIP_FILE}" dest="${selective-pull.DIR}"/>
                    <rh-sfdc:transformFiles srcDir="${selective-pull.DIR}" xslDir="@{xslDir}" operation="pull"/>
				</rh-util:then>

				<rh-util:else>
					<echo message="WARNING:  Nothing was downloaded and therefore nothing to copy..."/>
				</rh-util:else>
			</rh-util:ifFileExists>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="selective-pull-to-master" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - but using the types denoted in the types attribute">
		<attribute name="masterEnv"    default="${solenopsis.env.MASTER}"    description="The master environment where the data pulled from the dependent will be copied"/>
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}" description="The dependent environment to pull from"/>
		<attribute name="types"        default="${sf.types}"                 description="A comma separated list of types to pull"/>
		<attribute name="ignoreFile"   default="${sf.ignoreFile}"            description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="trace"        default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"      default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="batchSize"    default="${sf.batchSize}"             description="The number of items to retrieve in multi-part retrieves"/>
		<attribute name="description"  default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:selective-pull dependentEnv="@{dependentEnv}" types="@{types}" ignoreFile="@{ignoreFile}" trace="@{trace}" maxPoll="@{maxPoll}" batchSize="@{batchSize}"/>

			<copy toDir="${solenopsis.env.@{masterEnv}.HOME}">
				<fileset dir="${solenopsis.env.@{dependentEnv}.HOME}"/>
			</copy>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="generateRetrieveXml" uri="http://www.redhat.com/sfdc" language="beanshell" description="Generate a build.xml for a build retrieve">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="dir"/>
        <attribute name="antJar"/>
        <attribute name="username"/>
        <attribute name="password"/>
        <attribute name="serverurl"/>
        <attribute name="maxPoll"/>
        <attribute name="retrieveTarget"/>
        <attribute name="unpackaged"/>
        <attribute name="dumpFiles"/>
        <attribute name="showPasswords"/>

		<![CDATA[
            StringBuilder appendAttribute(StringBuilder sb, String name, String value) {
                sb.append(' ').append(name).append("='").append(value).append("'");
                return sb;
            }

            StringBuilder generateLine(StringBuilder sb, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String retrieveTarget, String unpackaged) {
                sb.append("    <sf:retrieve");
                appendAttribute(sb, "username", username);
                    
                appendAttribute(sb, "password", isShowPassword ? password : "");

                appendAttribute(sb, "serverurl", serverurl);
                appendAttribute(sb, "maxPoll", maxPoll);
                appendAttribute(sb, "retrieveTarget", retrieveTarget);
                appendAttribute(sb, "unpackaged", unpackaged);

                sb.append("/>\n");

                return sb;
            }

            StringBuilder generateTaskDef(StringBuilder sb, String antJar) {
                sb.append("    <taskdef resource='com/salesforce/antlib.xml' uri='antlib:com.salesforce'>\n");
                sb.append("        <classpath>\n");
                sb.append("            <fileset");
                appendAttribute(sb, "file", antJar);
                sb.append("/>\n");
                sb.append("        </classpath>\n");
                sb.append("    </taskdef>\n\n");

                return sb;
            }

            StringBuilder generateFile(StringBuilder sb, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String retrieveTarget, String unpackaged) {
                sb.append("<project basedir='.' xmlns:sf='antlib:com.salesforce'>\n");

                generateTaskDef(sb, antJar);
                generateLine(sb, isShowPassword, username, password, serverurl, maxPoll, retrieveTarget, unpackaged);

                sb.append("</project>\n");

                return sb;
            }

            String generateFile(String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String retrieveTarget, String unpackaged) {
                return generateFile(new StringBuilder(), antJar, isShowPassword, username, password, serverurl, maxPoll, retrieveTarget, unpackaged).toString(); 
            }

            boolean isBlank(String property) {
                return null == attributes.get(property) || "".equals(attributes.get(property).trim());
            }

            void writeFile(String dir, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String retrieveTarget, String unpackaged) {
                File realDir = new File(dir);
                realDir.mkdirs();

                File realFile = new File(realDir, "build.xml");
                FileWriter realFileWriter = new FileWriter(realFile);
                realFileWriter.write(generateFile(antJar, isShowPassword, username, password, serverurl, maxPoll, retrieveTarget, unpackaged));
                realFileWriter.close();

            }

            void writeFile(boolean isGenerateFile, String dir, String antJar, boolean isShowPassword, String username, String password, String serverurl, String maxPoll, String retrieveTarget, String unpackaged) {
                if (!isGenerateFile) {
                    return;
                }

                writeFile(dir, antJar, isShowPassword, username, password, serverurl, maxPoll, retrieveTarget, unpackaged);
            }

            writeFile(!isBlank("dumpfiles"), attributes.get("dir"),  attributes.get("antjar"), !isBlank("showpasswords"), attributes.get("username"), attributes.get("password"), attributes.get("serverurl"), attributes.get("maxpoll"), attributes.get("retrievetarget"), attributes.get("unpackaged"));
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

    <scriptdef name="mergePackageXml" uri="http://www.redhat.com/sfdc" language="beanshell" description="Merge XML contained in properties">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="property"/>
        <attribute name="packageXml"/>
        <attribute name="xmlToMerge"/>

		<![CDATA[
        
            // ---------------------------------------------------------------------

            import java.io.ByteArrayOutputStream;

            import java.util.List;
            import java.util.LinkedList;

            import javax.xml.transform.Result; 
            import javax.xml.transform.OutputKeys;
            import javax.xml.transform.TransformerFactory; 
            import javax.xml.transform.Transformer; 
            import javax.xml.transform.stream.StreamSource; 
            import javax.xml.transform.stream.StreamResult;

            // ---------------------------------------------------------------------
            // Will grab all child elements out of the project so we can stitch
            // them back together.
            // ---------------------------------------------------------------------

            //
            // May consider externalizing to a file...
            //
            String xsl = "<?xml version='1.0' encoding='UTF-8'?>\n" +
                "<xsl:transform version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns:sfdc='http://soap.sforce.com/2006/04/metadata' xmlns='http://soap.sforce.com/2006/04/metadata'>\n" +
                "    <xsl:output method='xml' omit-xml-declaration='yes' version='1.0'/>\n" + 
                "    <xsl:template match='/'>\n" +
                "        <xsl:apply-templates select='sfdc:Package'/>\n" + 
                "        <xsl:apply-templates select='sfdc:package'/>\n" + 
                "    </xsl:template>\n" + 
                "    <xsl:template match='sfdc:Package | sfdc:package'>\n" +
                "        <xsl:apply-templates mode='copy-mode'/>\n" +
                "    </xsl:template>\n" + 
                "    <xsl:template match='*' mode='copy-mode'>\n" +
                "        <xsl:copy-of select='.'/>\n" + 
                "    </xsl:template>\n" +
                "</xsl:transform>\n";

            String head = "<package xmlns='http://soap.sforce.com/2006/04/metadata'>\n";

            String tail = "</package>\n";

            // ---------------------------------------------------------------------
            // Returns true if str is null or blank
            // ---------------------------------------------------------------------

            boolean isBlank(String str) {
                return null == str || "".equals(str.trim());
            }

            // ---------------------------------------------------------------------
            // Returns true if the attribute is null or blank
            // ---------------------------------------------------------------------

            boolean isAttributeBlank(String attribute) {
                return isBlank(attributes.get(attribute));
            }

            // ---------------------------------------------------------------------

            Transformer createTransformer() {
                try {
                    return TransformerFactory.newInstance("com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl", null).newTransformer(new StreamSource(new StringReader(xsl)));
                } catch(Exception e) {
                    System.err.println("    *** Falling back to Saxon XSLT");
                }

                return TransformerFactory.newInstance("net.sf.saxon.TransformerFactoryImpl", null).newTransformer(new StreamSource(new StringReader(xsl)));
            }

            // ---------------------------------------------------------------------

            String transform(Transformer transformer, String xmlStr) {
                StreamSource input = new StreamSource(new StringReader(xmlStr));

                ByteArrayOutputStream baos = new ByteArrayOutputStream();

                StreamResult output = new StreamResult(baos);

                transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
                transformer.transform(input, output);

                String retVal = baos.toString();

                baos.close();

                return retVal;
            }

            String transform(String xmlStr) {
                return transform(createTransformer(), xmlStr).replaceAll(" xmlns=\"http://soap.sforce.com/2006/04/metadata\"", "");
            }

            // ---------------------------------------------------------------------

            String merge(StringBuilder sb, String packageXml, String toMerge) {
                return sb.append(head).append(transform(toMerge)).append(transform(packageXml)).append(tail).toString();
            }

            String merge(String packageXml, String toMerge) {
                return merge(new StringBuilder(), packageXml, toMerge);
            }

            // ---------------------------------------------------------------------

            project.setProperty(attributes.get("property"), isAttributeBlank("xmltomerge") ? attributes.get("packagexml") : merge(attributes.get("packagexml"), attributes.get("xmltomerge")));

            // ---------------------------------------------------------------------
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

	<macrodef name="non-folder-pull" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - it is a generic pull (non-folder based)">
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment to pull from"/>
		<attribute name="packageFile"        default="${sf.packageFile}"           description="A user supplied package.xml to use for deployment"/>
		<attribute name="includePackageFile" default="${sf.includePackageFile}"    description="A user supplied package.xml to supplement for pulling"/>
		<attribute name="ignoreFile"         default="${sf.ignoreFile}"            description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
        <attribute name="dumpFiles"          default="${sf.dumpFiles}"             description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords"      default="${sf.showPasswords}"         description="When generating a build.xml, will contain the token/password used"/>
        <attribute name="xslDir"             default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-util:ifUndefinedValue value="${solenopsis.env.@{dependentEnv}.HOME}">
                <rh-util:then>
                    <fail>
                        Please define [@{dependentEnv}] in solenopsis.ENVIRONMENTS!!!
                    </fail>
                </rh-util:then>
            </rh-util:ifUndefinedValue>

			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="non-folder-pull.USERNAME" webServicePassword="non-folder-pull.PASSWORD" url="non-folder-pull.URL" version="non-folder-pull.VERSION"/>

			<!--
				Were we supplied a user defined package.xml?
			-->
			<rh-util:ifEqual arg1="@{packageFile}" arg2="">
				<rh-util:then>
					<echo message="Generating package.xml"/>

					<!--
						Same package can be utilized.
					-->
					<rh-sfdc:xml-package property="non-folder-pull.PACKAGE" version="${non-folder-pull.VERSION}">
						<rh-sfdc:members-xml-types property="non-folder-pull.PACKAGE"/>
						<rh-sfdc:nonfolders-members-xml-types property="non-folder-pull.PACKAGE"/>
					</rh-sfdc:xml-package>
				</rh-util:then>

				<rh-util:else>
					<rh-util:ifFileExists file="@{packageFile}">
						<rh-util:then>
							<echo message="User defined package file being used [@{packageFile}]"/>

							<loadfile property="non-folder-pull.PACKAGE" srcFile="@{packageFile}"/>
						</rh-util:then>
						
						<rh-util:else>
							<fail message="Cannot load package file [@{packageFile}] - it does not exist!"/>
						</rh-util:else>
					</rh-util:ifFileExists>
				</rh-util:else>
			</rh-util:ifEqual>

			<rh-util:property name="non-folder-pull.tmp.DIR" value="${solenopsis.temp.DIR}/non-folder-pull"/>
			<delete dir="${non-folder-pull.tmp.DIR}"/>
			<mkdir dir="${non-folder-pull.tmp.DIR}"/>

            <xmlproperty file="@{replaceVarsFile}" collapseAttributes="true"/>

            <loadfile property="non-folder-pull.INCLUDE_PACKAGE_XML" srcFile="@{includePackageFile}" failonerror="false" quiet="true"/>

            <!--
                The loadfile may have failed...
            -->
            <rh-util:ifSet property="non-folder-pull.INCLUDE_PACKAGE_XML">
				<rh-util:then>
                    <rh-sfdc:mergePackageXml property="non-folder-pull.MERGE_PACKAGE" packageXml="${non-folder-pull.PACKAGE}" xmlToMerge="${non-folder-pull.INCLUDE_PACKAGE_XML}"/>
                    <rh-util:property name="non-folder-pull.PACKAGE" value="${non-folder-pull.MERGE_PACKAGE}"/>
                </rh-util:then>
            </rh-util:ifSet>

			<rh-util:property name="non-folder-pull.PACKAGE-FILE" value="${non-folder-pull.tmp.DIR}/non-folder-pull.package.xml"/>

			<echo message="${non-folder-pull.PACKAGE}" file="${non-folder-pull.PACKAGE-FILE}"/>

			<echo>

				Processing:  [@{dependentEnv}]

				URL:         [${non-folder-pull.URL}]
				API:         [${non-folder-pull.VERSION}]

				Jar:         [${sf.migrationToolJar}]

			</echo>

			<rh-util:property name="non-folder-pull.DIR" value="${solenopsis.env.@{dependentEnv}.HOME}"/>

			<delete dir="${non-folder-pull.DIR}"/>
			<mkdir  dir="${non-folder-pull.DIR}"/>

            <rh-sfdc:generateRetrieveXml dir="${non-folder-pull.tmp.DIR}" antJar="${sf.migrationToolJar}" username="${non-folder-pull.USERNAME}" password="${non-folder-pull.PASSWORD}" serverurl="${non-folder-pull.URL}" maxPoll="@{maxPoll}" retrieveTarget="${non-folder-pull.tmp.DIR}" unpackaged="${non-folder-pull.PACKAGE-FILE}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

			<sf:retrieve username="${non-folder-pull.USERNAME}" password="${non-folder-pull.PASSWORD}" serverurl="${non-folder-pull.URL}" maxPoll="@{maxPoll}" retrieveTarget="${non-folder-pull.tmp.DIR}" unpackaged="${non-folder-pull.PACKAGE-FILE}"/>

			<!--
				Clean up the package file...
			-->
			<delete file="${non-folder-pull.PACKAGE-FILE}"/>

			<rh-util:property name="non-folder-pull.ZIP_FILE" value="${non-folder-pull.tmp.DIR}/non-folder-pull.zip"/>

			<!--
				If an excludes file is passed in, use that for the zip task, otherwise,
				just call out to zip without it.  Unfortunately, zip complains if one
				presents an empty string...
			-->
			<rh-util:ifNotEqual arg1="@{ignoreFile}" arg2="">
				<rh-util:then>
					<zip destfile="${non-folder-pull.ZIP_FILE}" basedir="${non-folder-pull.tmp.DIR}" excludesfile="@{ignoreFile}" level="9"/>
				</rh-util:then>

				<rh-util:else>
					<zip destfile="${non-folder-pull.ZIP_FILE}" basedir="${non-folder-pull.tmp.DIR}" level="9"/>
				</rh-util:else>
			</rh-util:ifNotEqual>

			<unzip src="${non-folder-pull.ZIP_FILE}" dest="${non-folder-pull.DIR}"/>

            <rh-sfdc:transformFiles srcDir="${non-folder-pull.DIR}" xslDir="@{xslDir}" operation="pull"/>

            <rh-sfdc:purge-ignores-refs env="@{dependentEnv}"/>

			<!--
			<rh-sfdc:generate-objects-properties env="@{dependentEnv}" description="Recreate the properties for the objects"/>
			-->
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="non-folder-pull-to-master" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - it is a generic pull (non-folder based)">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment where the data pulled from the dependent will be copied"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment to pull from"/>
		<attribute name="packageFile"        default="${sf.packageFile}"           description="A user supplied package.xml to use for deployment"/>
		<attribute name="includePackageFile" default="${sf.includePackageFile}"    description="A user supplied package.xml to supplement for pulling"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-sfdc:non-folder-pull dependentEnv="@{dependentEnv}" packageFile="@{packageFile}" includePackageFile="@{includePackageFile}" trace="@{trace}" maxPoll="@{maxPoll}"/>

			<copy toDir="${solenopsis.env.@{masterEnv}.HOME}">
				<fileset dir="${solenopsis.env.@{dependentEnv}.HOME}"/>
			</copy>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="folder-pull" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - it is a generic pull (folder based)">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment who has the correct folders defined"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to pull"/>
		<attribute name="packageFile"        default="${sf.packageFile}"           description="A user supplied package.xml to use for deployment"/>
		<attribute name="includePackageFile" default="${sf.includePackageFile}"    description="A user supplied package.xml to supplement for pulling"/>
		<attribute name="ignoreFile"         default="${sf.ignoreFile}"            description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
        <attribute name="dumpFiles"          default="${sf.dumpFiles}"             description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords"      default="${sf.showPasswords}"         description="When generating a build.xml, will contain the token/password used"/>
        <attribute name="xslDir"             default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-util:ifUndefinedValue value="${solenopsis.env.@{dependentEnv}.HOME}">
                <rh-util:then>
                    <fail>
                        Please define [@{dependentEnv}] in solenopsis.ENVIRONMENTS!!!
                    </fail>
                </rh-util:then>
            </rh-util:ifUndefinedValue>

			<!--
				Define our temporary "scratch" area..
			-->
			<rh-util:property name="folder-pull.tmp.DIR" value="${solenopsis.temp.DIR}/folder-pull"/>
			<delete dir="${folder-pull.tmp.DIR}"/>
			<mkdir dir="${folder-pull.tmp.DIR}"/>

			<rh-util:property name="folder-pull.PACKAGE-FILE" value="${folder-pull.tmp.DIR}/folder-pull.package.xml"/>

			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="folder-pull.USERNAME" webServicePassword="folder-pull.PASSWORD" url="folder-pull.URL" version="folder-pull.VERSION"/>

			<!--
				Were we supplied a user defined package.xml?
			-->
			<rh-util:ifEqual arg1="@{packageFile}" arg2="">
				<rh-util:then>
					<echo message="Generating package.xml"/>

					<!--
						Same package can be utilized.
					-->
					<rh-sfdc:xml-package property="folder-pull.PACKAGE" version="${folder-pull.VERSION}">
						<rh-sfdc:members-xml-types property="folder-pull.PACKAGE"/>
						<rh-sfdc:nonfolders-members-xml-types property="folder-pull.PACKAGE"/>

						<rh-sfdc:folders-members-xml-types property="folder-pull.PACKAGE" env="@{masterEnv}"/>
					</rh-sfdc:xml-package>
				</rh-util:then>

				<rh-util:else>
					<rh-util:ifFileExists file="@{packageFile}">
						<rh-util:then>
							<echo message="User defined package file being used [@{packageFile}]"/>

							<loadfile property="folder-pull.PACKAGE" srcFile="@{packageFile}"/>
						</rh-util:then>
						
						<rh-util:else>
							<fail message="Cannot load package file [@{packageFile}] - it does not exist!"/>
						</rh-util:else>
					</rh-util:ifFileExists>
				</rh-util:else>
			</rh-util:ifEqual>

            <loadfile property="folder-pull.INCLUDE_PACKAGE_XML" srcFile="@{includePackageFile}" failonerror="false" quiet="true"/>

            <!--
                The loadfile may have failed...
            -->
            <rh-util:ifSet property="folder-pull.INCLUDE_PACKAGE_XML">
				<rh-util:then>
                    <rh-sfdc:mergePackageXml property="folder-pull.MERGE_PACKAGE" packageXml="${folder-pull.PACKAGE}" xmlToMerge="${folder-pull.INCLUDE_PACKAGE_XML}"/>
                    <rh-util:property name="folder-pull.PACKAGE" value="${folder-pull.MERGE_PACKAGE}"/>
                </rh-util:then>
            </rh-util:ifSet>

			<echo message="${folder-pull.PACKAGE}" file="${folder-pull.PACKAGE-FILE}"/>

			<echo>

				Processing:  [@{dependentEnv}]

				URL:         [${folder-pull.URL}]
				API:         [${folder-pull.VERSION}]

				Jar:         [${sf.migrationToolJar}]

			</echo>

			<rh-util:property name="folder-pull.DIR" value="${solenopsis.env.@{dependentEnv}.HOME}"/>

			<delete dir="${folder-pull.DIR}"/>
			<mkdir  dir="${folder-pull.DIR}"/>

            <rh-sfdc:generateRetrieveXml dir="${folder-pull.tmp.DIR}" antJar="${sf.migrationToolJar}" username="${folder-pull.USERNAME}" password="${folder-pull.PASSWORD}" serverurl="${folder-pull.URL}" maxPoll="@{maxPoll}" retrieveTarget="${folder-pull.tmp.DIR}" unpackaged="${folder-pull.PACKAGE-FILE}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

			<sf:retrieve username="${folder-pull.USERNAME}" password="${folder-pull.PASSWORD}" serverurl="${folder-pull.URL}" maxPoll="@{maxPoll}" retrieveTarget="${folder-pull.tmp.DIR}" unpackaged="${folder-pull.PACKAGE-FILE}"/>

			<!--
				Clean up the package file...
			-->
			<delete file="${folder-pull.PACKAGE-FILE}"/>

			<rh-util:property name="folder-pull.ZIP_FILE" value="${folder-pull.tmp.DIR}/folder-pull.zip"/>

			<!--
				If an excludes file is passed in, use that for the zip task, otherwise,
				just call out to zip without it.  Unfortunately, zip complains if one
				presents an empty string...
			-->
			<rh-util:ifNotEqual arg1="@{ignoreFile}" arg2="">
				<rh-util:then>
					<zip destfile="${folder-pull.ZIP_FILE}" basedir="${folder-pull.tmp.DIR}" excludesfile="@{ignoreFile}" level="9"/>
				</rh-util:then>

				<rh-util:else>
					<zip destfile="${folder-pull.ZIP_FILE}" basedir="${folder-pull.tmp.DIR}" level="9"/>
				</rh-util:else>
			</rh-util:ifNotEqual>

			<unzip src="${folder-pull.ZIP_FILE}" dest="${folder-pull.DIR}"/>

            <rh-sfdc:transformFiles srcDir="${folder-pull.DIR}" xslDir="@{xslDir}" operation="pull"/>

            <rh-sfdc:purge-ignores-refs env="@{dependentEnv}"/>

			<!--
			<rh-sfdc:generate-objects-properties env="@{dependentEnv}" description="Recreate the properties for the objects"/>
			-->
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="folder-pull-to-master" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will pull from an SFDC environment - it is a generic pull (folder based)">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment who has the correct folders defined"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to pull"/>
		<attribute name="packageFile"        default="${sf.packageFile}"           description="A user supplied package.xml to use for deployment"/>
		<attribute name="includePackageFile" default="${sf.includePackageFile}"    description="A user supplied package.xml to supplement for pulling"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-sfdc:folder-pull dependentEnv="@{dependentEnv}" packageFile="@{packageFile}" includePackageFile="@{includePackageFile}" trace="@{trace}" maxPoll="@{maxPoll}"/>

			<copy toDir="${solenopsis.env.@{masterEnv}.HOME}">
				<fileset dir="${solenopsis.env.@{dependentEnv}.HOME}"/>
			</copy>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <!-- Will find any file entitled fileName.xsl and apply that to a file of the same name.  Looks for the dir in xslDir and uses that. -->

    <scriptdef name="transformFiles" uri="http://www.redhat.com/sfdc" language="beanshell" description="Starting at @{srcDir}, transform using XSLTs found in ${xslDir}">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="srcDir"/>
        <attribute name="xslDir"/>
        <attribute name="operation"/>

		<![CDATA[
            import java.io.ByteArrayOutputStream;

            import java.util.List;
            import java.util.LinkedList;

            import javax.xml.transform.Result; 
            import javax.xml.transform.OutputKeys;
            import javax.xml.transform.TransformerFactory; 
            import javax.xml.transform.Transformer; 
            import javax.xml.transform.stream.StreamSource; 
            import javax.xml.transform.stream.StreamResult; 


            //
            // Filters for directories
            //
            class DirFilter implements FileFilter {
                public boolean accept(File dir) {
                    return dir.isDirectory();
                }
            }

            //
            // Filters for XSL files.
            //
            class XslFileFilter implements FilenameFilter {
                File getFile(File dir, String name) {
                    return new File(dir, name);
                }

                boolean isXslFile(File file) {
                    return file.isFile() && file.getName().endsWith(".xsl");
                }

                public boolean accept(File dir, String name) {
                    return isXslFile(new File(dir, name));
                }
            }

            //
            // Filters for files who have name (minus extension).
            //
            class ExtensionlessFileFilter implements FilenameFilter {
                String baseFile;
                String operation;

                ExtensionlessFileFilter(String baseFile, String operation) {
                    this.baseFile = baseFile;
                    this.operation = operation;
                }

                public boolean accept(File dir, String name) {
                    return baseFile.replaceAll("_" + operation, "").equals(name.substring(0, name.lastIndexOf(".")));
                }
            }

            List convertFileArray(File[] files) {
                return (null == files ? Collections.EMPTY_LIST : Arrays.asList(files));
            }

            //
            // Finds all XSL files in subDirs (and subDirs child dirs).
            //
            List findAllXsls(List xslFileList, File[] subDirs, XslFileFilter filter, DirFilter dirFilter) {
                for(File subDir : subDirs) {
                    findAllXsls(xslFileList, subDir, filter, dirFilter);
                }

                return xslFileList;
            }

            //
            // Finds all XSL files in dir (and child directories of dir).
            //
            List findAllXsls(List xslFileList, File dir, XslFileFilter xslFileFilter, DirFilter dirFilter) {
                xslFileList.addAll(convertFileArray(dir.listFiles(xslFileFilter)));

                return findAllXsls(xslFileList, dir.listFiles(dirFilter), xslFileFilter, dirFilter);
            }

            //
            // Finds all XSL files starting in dir.
            //
            List findAllXsls(File dir) {
                DirFilter dirFilter = new DirFilter();

                return findAllXsls(new LinkedList(), dir.listFiles(dirFilter), new XslFileFilter(), dirFilter);
            }

            //
            // Finds all XSL from the File representaion starting in dir.
            //
            List findAllXsls(String dir) {
                return findAllXsls(new File(dir));
            }

            //
            // From dir, compute the file name minus extension.
            //
            String computeBranch(String file, String dir) {
                return file.substring(dir.length() + 1, file.lastIndexOf("."));
            }

            //
            // From dir, compute the file name minus extension.
            //
            String computeBranch(File file, String dir) {
                return computeBranch(file.getAbsolutePath(), dir);
            }

            //
            // Find a file should should have XSL applied.
            //
            File findFileToApply(String branch, File srcDir, String operation) {
                File baseDir = new File(branch);
                File dir = new File(srcDir, baseDir.getParent());

                File[] files = dir.listFiles(new ExtensionlessFileFilter(baseDir.getName(), operation));

                if (null == files || files.length < 1) {
                    System.out.println("WARNING:  no transformable file found for [" + branch + ".xsl]");
                    return null;
                }

                return files[0];
            }

            //
            // Find a file should should have XSL applied.
            //
            File findFileToApply(String branch, String srcDir, String operation) {
                return findFileToApply(branch, new File(srcDir), operation);
            }

            //
            // Do we have a file?
            //
            boolean isFileFound(File file) {
                return null != file;
            }

            //
            // Convert from entity definitions by making them a different looking version...
            //
            String convertFromEntityDefinitions(File srcFile) {
                RandomAccessFile raf = new RandomAccessFile(srcFile, "r");
                byte[] rawFile = new byte[(int) srcFile.length()];

                raf.read(rawFile);

                raf.close();

                return new String(rawFile).replaceAll("&amp;", "__amp__amp__;").replaceAll("&apos;", "__amp__apos__;").replaceAll("&lt;", "__amp__lt__;").replaceAll("&gt;", "__amp__gt__;").replaceAll("&quot;", "__amp__quot__;");
            }

            //
            // Convert to entity definitions by making them look like the real deal...
            //
            String convertToEntityDefinitions(String str) {
                return str.replaceAll("__amp__amp__;", "&amp;").replaceAll("__amp__apos__;", "&apos;").replaceAll("__amp__lt__;", "&lt;").replaceAll("__amp__gt__;", "&gt;").replaceAll("__amp__quot__;", "&quot;");
            }

            //
            // Transform a file.
            //
            void transformFile(Transformer transformer, String xslDir, File xslFile, String srcDir, String operation) {
                File srcFile = findFileToApply(computeBranch(xslFile, xslDir), srcDir, operation);

                if (! isFileFound(srcFile)) {
                    return;
                }

                System.out.println("Transforming [" + srcFile +"]\n     XSL [" + xslFile + "]");

                long startTime = System.currentTimeMillis();

                StreamSource input = new StreamSource(new StringReader(convertFromEntityDefinitions(srcFile)));

                ByteArrayOutputStream baos = new ByteArrayOutputStream();

                StreamResult output = new StreamResult(baos);

                transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
                transformer.transform(input, output);

                FileWriter fw = new FileWriter(srcFile);

                // Removing any extraneous extra spaces added...
                String str = convertToEntityDefinitions(new String(baos.toByteArray())).replaceAll(">" + System.getProperty("line.separator") + "\\s+" + System.getProperty("line.separator"), ">\n").replaceAll("><", ">\n<");

                fw.write(str);

                fw.flush();
                fw.close();
                baos.close();

                long stopTime = System.currentTimeMillis();

                System.out.println("     Time to transform [" + (stopTime - startTime) + " ms]");
            }

            //
            // Transform a file.
            //
            void transformFile(String xslDir, File xslFile, String srcDir, String operation) {
                try {
                    return transformFile(TransformerFactory.newInstance("com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl", null).newTransformer(new StreamSource(xslFile)), xslDir, xslFile, srcDir, operation);
                } catch (Exception e) {
                    System.out.println("     Falling back to saxon");
                }

                return transformFile(TransformerFactory.newInstance("net.sf.saxon.TransformerFactoryImpl", null).newTransformer(new StreamSource(xslFile)), xslDir, xslFile, srcDir, operation);
            }

            //
            // Transform a file.
            //
            void transformFile(String xslDir, String xslFile, String srcDir, String operation) {
                return transformFile(xslDir, new File(xslFile), srcDir, operation);
            }

            //
            // If the XSL is for push operations but its a pull XSL, return false...
            //
            boolean isXslNotForPush(File xslFile, String operation) {
                return "push".equals(operation) && xslFile.getName().endsWith("_pull.xsl");
            }

            //
            // If the XSL is for pull operations but its a push XSL, return false...
            //
            boolean isXslNotForPull(File xslFile, String operation) {
                return "pull".equals(operation) && xslFile.getName().endsWith("_push.xsl");
            }

            //
            // Can we use the XSL?  We can if it has no underscore or it
            // contains the value of operation...
            //
            boolean canUseXsl(File xslFile, String operation) {
                if (isXslNotForPush(xslFile, operation) || isXslNotForPull(xslFile, operation)) {
                    return false;
                }

                return true;
            }

            //
            // Transform all files...
            //
            void transformFiles(String xslDir, List xslFileList, String srcDir, String operation) {
                System.out.print("Total XSLs [" + xslFileList.size() + "]:");
                System.out.println(xslFileList.toString().replaceAll(",", "\n\t").replaceAll("\\[", "\n\t ").replaceAll("\\]",""));

                for (File xslFile : xslFileList) {
                    if (canUseXsl(xslFile, operation)) {
                        transformFile(xslDir, xslFile, srcDir, operation);
                    }
                }
            }

            boolean isXslDir(File xslDir) {
                return xslDir.isDirectory();
            }

            boolean isXslDir(String xslDir) {
                return null != xslDir && isXslDir(new File(xslDir));
            }

            String ensureNoTrailingSlash(String dir) {
                if (null == dir) {
                    return null;
                }

                if (dir.length() < 1) {
                    System.out.println("WARNING:  directory is an empty string");
                    return dir;
                }

                if (!dir.endsWith(System.getProperty("file.separator"))) {
                    return dir;
                }

                return dir.substring(0, dir.length() - 1);
            }

            String xslDir = ensureNoTrailingSlash(attributes.get("xsldir"));

            if (isXslDir(xslDir)) {
                transformFiles(xslDir, findAllXsls(xslDir), attributes.get("srcdir"), attributes.get("operation"));
            } else {
                System.out.println("WARNING:  No xsl directory found for [" + xslDir + "]");
            }
        ]]>
	</scriptdef>

    <!-- =========================================================================================== -->

	<macrodef name="retrieveMetadata" backtrace="true" uri="http://www.redhat.com/sfdc" description="Retrieve metadata">
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to pull metadata"/>
		<attribute name="dir"                                                description="The directory containing files that may contain file that should be ignored"/>
        <attribute name="metadataType"                                       description="The type of metadata to retrieve"/>
		<attribute name="maxPoll"      default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
        <attribute name="batchSize"    default="${sf.batchSize}"             description="The batch size to use when retrieving metadata"/>
		<attribute name="description"  default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="retrieveMetadata.USERNAME" webServicePassword="retrieveMetadata.PASSWORD" url="retrieveMetadata.URL" version="retrieveMetadata.VERSION"/>
			<mkdir dir="@{dir}"/>

            <ac:trycatch property="retrieveMetadata.FAILURE">
                <ac:try>
                    <sf:bulkRetrieve username="${retrieveMetadata.USERNAME}" password="${retrieveMetadata.PASSWORD}" serverurl="${retrieveMetadata.URL}" maxPoll="@{maxPoll}" metadataType="@{metadataType}" retrieveTarget="@{dir}" batchSize="@{batchSize}" apiVersion="${retrieveMetadata.VERSION}" unzip="true"/>
                </ac:try>

                <ac:catch>
                    <echo>
                        WARNING RETRIEVING [@{metadataType}]:  ${retrieveMetadata.FAILURE}

                        IGNORING [@{metadataType}]
                    </echo>
                </ac:catch>
            </ac:trycatch>
        </sequential>
    </macrodef>
    <!-- =========================================================================================== -->

	<macrodef name="retrieveImplicitMetadata" backtrace="true" uri="http://www.redhat.com/sfdc" description="Retrieve implicit metadata">
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to pull metadata"/>
		<attribute name="dir"                                                description="The directory containing files that may contain file that should be ignored"/>
		<attribute name="maxPoll"      default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
        <attribute name="batchSize"    default="${sf.batchSize}"             description="The batch size to use when retrieving metadata"/>
		<attribute name="description"  default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-sfdc:retrieveMetadata dependentEnv="@{dependentEnv}" dir="@{dir}" metadataType="${sf.metadata.flowDefinitions}"      maxPoll="@{maxPoll}" batchSize="@{batchSize}"/>
            <rh-sfdc:retrieveMetadata dependentEnv="@{dependentEnv}" dir="@{dir}" metadataType="${sf.metadata.entitlementProcesses}" maxPoll="@{maxPoll}" batchSize="@{batchSize}"/>
            <rh-sfdc:retrieveMetadata dependentEnv="@{dependentEnv}" dir="@{dir}" metadataType="${sf.metadata.milestoneTypes}"       maxPoll="@{maxPoll}" batchSize="@{batchSize}"/>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="removeImplicitIgnores" uri="http://www.redhat.com/sfdc" language="beanshell" description="Compute the flows to ignore">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="metadatadir"/>
        <attribute name="removedir"/>

		<![CDATA[
            import java.io.File;
            import java.io.FileInputStream;
            import java.io.IOException;

            import org.xml.sax.InputSource;

            import javax.xml.xpath.XPath;
            import javax.xml.xpath.XPathExpression;
            import javax.xml.xpath.XPathFactory;


            // -------------------------------------------------------------
            // Close the input stream...
            // -------------------------------------------------------------
            void close(InputStream is) {
                try {
                    is.close();
                } catch (IOException ioException) {
                    System.err.println("Trouble closing input stream!");
                }
            }

            // -------------------------------------------------------------
            // Using XPath, pull out the version of the flow...
            // -------------------------------------------------------------
            String computeVersion(XPath xpath, InputSource is) {
                return xpath.evaluate("//*[local-name() = 'activeVersionNumber']/text()", is);
            }

            // -------------------------------------------------------------
            // Using XPath, pull out the version of the flow from the file...
            // -------------------------------------------------------------
            String computeVersion(XPath xpath, FileInputStream fis) {
                String retVal = "";

                try {
                     retVal = computeVersion(xpath, new InputSource(fis));
                } finally {
                    close(fis);
                }

                return retVal;
            }

            // -------------------------------------------------------------
            // Using XPath, pull out the version of the flow from the file...
            // -------------------------------------------------------------
            String computeVersion(XPath xpath, File flowDefinition) {
                return computeVersion(xpath, new FileInputStream(flowDefinition));
            }

            // -------------------------------------------------------------
            // Compute a file array from a list - if null, return an empty array...
            // -------------------------------------------------------------
            File[] computeFiles(File[] files) {
                return null == files ? new File[0] : files;
            }

            // -------------------------------------------------------------
            // Compute the base name of the file...
            // -------------------------------------------------------------
            String computeBaseName(File file) {
                return file.getName().split("\\.") [0];
            }

            // -------------------------------------------------------------
            // Compute the maximum version of a flow.
            // -------------------------------------------------------------
            int computeMaxFlowVersion(XPath xpath, File flowDefinition) {
                try {
                    return Integer.parseInt(computeVersion(xpath, flowDefinition)) + 1;
                } catch (NumberFormatException nfe) {
                    System.out.println("Trouble converting flow [" + flowDefinition + "] to a version...returning 1");
                    return 1;
                }
            }

            // -------------------------------------------------------------
            // Remove any flows.
            // -------------------------------------------------------------
            void removeFlows(XPath xpath, File[] toRemove, File removeDir) {
                for (File flowDefinition : toRemove) {
                    int maxVersion = computeMaxFlowVersion(xpath, flowDefinition);

                    for (int version = 1; version < maxVersion; version++) {
                        File removeFile = new File(removeDir, computeBaseName(flowDefinition) + "-" + version + ".flow");

                        System.out.print("        " + removeFile + ": ");
                        System.out.println(removeFile.delete());
                    }
                }
            }

            // -------------------------------------------------------------
            // Remove any flows.
            // -------------------------------------------------------------
            void removeFlows(File metadataDir, File removeDir) {
                System.out.println("    Removing the following flows from deployment:");

                removeFlows(XPathFactory.newInstance().newXPath(), computeFiles(new File(removeDir, "flowDefinitions").listFiles()), new File(removeDir, "flows"));
            }

            // -------------------------------------------------------------
            // Remove individual files from a dir...
            // -------------------------------------------------------------
            void removeIndividualFiles(File[] toRemove, File removeDir) {
                System.out.println("    Removing the following " + removeDir.getName() + " from deployment:");

                for (File aFile : toRemove) {
                    File removeFile = new File(removeDir, aFile.getName());

                    System.out.print("        " + removeFile + ": ");
                    System.out.println(removeFile.delete());
                }
            }


            // -------------------------------------------------------------
            // Remove individual files (ones that do not require special
            // processing...
            // -------------------------------------------------------------
            void removeIndividualFiles(File metadataDir, File removeDir) {
                removeIndividualFiles(computeFiles(new File(metadataDir, "entitlementProcesses").listFiles()), new File(removeDir, "entitlementProcesses"));
                removeIndividualFiles(computeFiles(new File(metadataDir, "milestoneTypes").listFiles()), new File(removeDir, "milestoneTypes"));
            }

            // -------------------------------------------------------------
            // Ensure dirs exists...
            // -------------------------------------------------------------
            boolean dirsExist(File metadataDir, File removeDir) {
                return metadataDir.exists() && removeDir.exists();
            }

            // -------------------------------------------------------------
            // Remove files...
            // -------------------------------------------------------------
            void removeFiles(File metadataDir, File removeDir) {
                if (!dirsExist(metadataDir, removeDir)) {
                    System.out.println("    WARNING: metadata dir [" + metadataDir + "] and/or remove dir [" + removeDir + "] do not exist!  IGNORING");  
                    return;
                }

                removeFlows(metadataDir, removeDir);
                removeIndividualFiles(metadataDir, removeDir);
            }

            // -------------------------------------------------------------
            // Remove files...
            // -------------------------------------------------------------
            void removeFiles(String metadataDir, String removeDir) {
                System.out.println("Removing implicit ignore files in [" + removeDir + "]:");

                removeFiles(new File(metadataDir), new File(removeDir));
            }

            // -------------------------------------------------------------
            // Main entry of script...
            // -------------------------------------------------------------
            removeFiles(attributes.get("metadatadir"), attributes.get("removedir"));
        ]]>
	</scriptdef>

	<macrodef name="processImplicitIgnores" backtrace="true" uri="http://www.redhat.com/sfdc" description="Process implicit ignores">
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to pull metadata"/>
		<attribute name="dir"                                                description="The directory containing files that may contain file that should be ignored"/>
		<attribute name="maxPoll"      default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
        <attribute name="batchSize"    default="${sf.batchSize}"              description="The batch size to use when retrieving metadata"/>
		<attribute name="description"  default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="processImplicitIgnores.USERNAME" webServicePassword="processImplicitIgnores.PASSWORD" url="processImplicitIgnores.URL" version="processImplicitIgnores.VERSION"/>
			<rh-util:property name="processImplicitIgnores.tmp.DIR" value="${solenopsis.temp.DIR}/processImplicitIgnores-meta"/>
			<delete dir="${processImplicitIgnores.tmp.DIR}"/>
			<mkdir dir="${processImplicitIgnores.tmp.DIR}"/>

            <rh-sfdc:retrieveImplicitMetadata dependentEnv="@{dependentEnv}" dir="${processImplicitIgnores.tmp.DIR}" maxPoll="@{maxPoll}" batchSize="@{batchSize}"/>

            <rh-sfdc:removeImplicitIgnores metadatadir="${processImplicitIgnores.tmp.DIR}" removedir="@{dir}"/>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="generateDeployXml" uri="http://www.redhat.com/sfdc" language="beanshell" description="Generate a build.xml for a build retrieve">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="dir"/>
        <attribute name="antJar"/>
        <attribute name="apiVersion"/>
        <attribute name="username"/>
        <attribute name="password"/>
        <attribute name="serverurl"/>
        <attribute name="zipFile"/>
        <attribute name="trace"/>
        <attribute name="runAllTests"/>
        <attribute name="maxPoll"/>
        <attribute name="allowMissingFiles"/>
        <attribute name="checkOnly"/>
        <attribute name="logType"/>
        <attribute name="ignoreWarnings"/>
        <attribute name="dumpFiles"/>
        <attribute name="showPasswords"/>

		<![CDATA[
            StringBuilder appendAttribute(StringBuilder sb, String name, String value) {
                sb.append(' ').append(name).append("='").append(value).append("'");
                return sb;
            }

            boolean isRunAllTests(String apiVersion) {
                return new Double(apiVersion).doubleValue() < 34.0;
            }

            String computeTestLevel(String runAllTests) {
                return runAllTests.equalsIgnoreCase("false") ? "NoTestRun" : "RunLocalTests";
            }

            StringBuilder generateTestAttribute(StringBuilder sb, String apiVersion, String runAllTests) {
                if (isRunAllTests(apiVersion)) {
                    return appendAttribute(sb, "runAllTests", runAllTests); 
                }

                return appendAttribute(sb, "testLevel", computeTestLevel(runAllTests));
            }
            
            StringBuilder generateLine(StringBuilder sb, String apiVersion, boolean isShowPassword, String username, String password, String serverurl, String zipFile, String trace, String runAllTests, String maxPoll, String allowMissingFiles, String checkOnly, String logType, String ignoreWarnings) {
                sb.append("    <sf:deploy");
                appendAttribute(sb, "username", username);
                    
                appendAttribute(sb, "password", isShowPassword ? password : "");

                appendAttribute(sb, "serverurl", serverurl);
                appendAttribute(sb, "zipFile", zipFile);
                appendAttribute(sb, "trace", trace);

                generateTestAttribute(sb, apiVersion, runAllTests);

                appendAttribute(sb, "maxPoll", maxPoll);
                appendAttribute(sb, "allowMissingFiles", allowMissingFiles);
                appendAttribute(sb, "checkOnly", checkOnly);
                appendAttribute(sb, "logType", logType);
                appendAttribute(sb, "ignoreWarnings", ignoreWarnings);

                sb.append("/>\n");

                return sb;
            }

            StringBuilder generateTaskDef(StringBuilder sb, String antJar) {
                sb.append("    <taskdef resource='com/salesforce/antlib.xml' uri='antlib:com.salesforce'>\n");
                sb.append("        <classpath>\n");
                sb.append("            <fileset");
                appendAttribute(sb, "file", antJar);
                sb.append("/>\n");
                sb.append("        </classpath>\n");
                sb.append("    </taskdef>\n\n");

                return sb;
            }

            StringBuilder generateFile(StringBuilder sb, String antJar, String apiVersion, boolean isShowPassword, String username, String password, String serverurl, String zipFile, String trace, String runAllTests, String maxPoll, String allowMissingFiles, String checkOnly, String logType, String ignoreWarnings) {
                sb.append("<project basedir='.' xmlns:sf='antlib:com.salesforce'>\n");

                generateTaskDef(sb, antJar);
                generateLine(sb, apiVersion, isShowPassword, username, password, serverurl, zipFile, trace, runAllTests, maxPoll, allowMissingFiles, checkOnly, logType, ignoreWarnings);

                sb.append("</project>\n");

                return sb;
            }

            String generateFile(String antJar, String apiVersion, boolean isShowPassword, String username, String password, String serverurl, String zipFile, String trace, String runAllTests, String maxPoll, String allowMissingFiles, String checkOnly, String logType, String ignoreWarnings) {
                return generateFile(new StringBuilder(), antJar, apiVersion, isShowPassword, username, password, serverurl, zipFile, trace, runAllTests, maxPoll, allowMissingFiles, checkOnly, logType, ignoreWarnings).toString(); 
            }

            boolean isBlank(String property) {
                return null == attributes.get(property) || "".equals(attributes.get(property).trim());
            }

            void writeFile(String dir, String antJar, String apiVersion, boolean isShowPassword, String username, String password, String serverurl, String zipFile, String trace, String runAllTests, String maxPoll, String allowMissingFiles, String checkOnly, String logType, String ignoreWarnings) {
                File realDir = new File(dir);
                realDir.mkdirs();

                File realFile = new File(realDir, "build.xml");
                FileWriter realFileWriter = new FileWriter(realFile);
                realFileWriter.write(generateFile(antJar, apiVersion, isShowPassword, username, password, serverurl, zipFile, trace, runAllTests, maxPoll, allowMissingFiles, checkOnly, logType, ignoreWarnings));
                realFileWriter.close();
            }

            void writeFile(boolean isGenerateFile, String dir, String antJar, String apiVersion, boolean isShowPassword, String username, String password, String serverurl, String zipFile, String trace, String runAllTests, String maxPoll, String allowMissingFiles, String checkOnly, String logType, String ignoreWarnings) {
                if (!isGenerateFile) {
                    return;
                }

                writeFile(dir, antJar, apiVersion, isShowPassword, username, password, serverurl, zipFile, trace, runAllTests, maxPoll, allowMissingFiles, checkOnly, logType, ignoreWarnings);
            }

            writeFile(!isBlank("dumpfiles"), attributes.get("dir"), attributes.get("antjar"), attributes.get("apiversion"), !isBlank("showpasswords"), attributes.get("username"), attributes.get("password"), attributes.get("serverurl"), attributes.get("zipfile"), attributes.get("trace"), attributes.get("runalltests"), attributes.get("maxpoll"), attributes.get("allowmissingfiles"), attributes.get("checkonly"), attributes.get("logtype"), attributes.get("ignorewarnings"));
            ]]>
	</scriptdef>

	<macrodef name="file-push" backtrace="true" uri="http://www.redhat.com/sfdc" description="This pushes a list of files from @{masterEnv} to @{dependentEnv}">
		<attribute name="masterEnv"              default="${solenopsis.env.MASTER}"     description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"           default="${solenopsis.env.DEPENDENT}"  description="The dependent environment from which to push"/>
		<attribute name="addFileList"                                                   description="A list of files to push out to @{dependentEnv}"/>
		<attribute name="removeFileList"         default=""                             description="A list of files to remove from @{dependentEnv}"/>
        <attribute name="removeFieldList"        default=""                             description="A list of fields to remove in a SFDC type=value format"/>
        <attribute name="destructiveChangesFile" default="${sf.destructiveChangesFile}" description="The file name to call destructiveChanges.xml"/>
		<attribute name="fileDelimiter"          default="${path.separator}"            description="A list of files to push out to @{dependentEnv}"/>
		<attribute name="trace"                  default="${sf.trace}"                  description="Trace the call to SFDC on deploy"/>
		<attribute name="runAllTests"            default="${sf.runAllTests}"            description="Flag, if true all tests will be run upon deployment"/>
        <attribute name="testLevel"              default="${sf.testLevel}"              description="Denotes the test level to run upon deployment NoTestRun, RunLocalTests, RunAllTestsInOrg"/>
		<attribute name="maxPoll"                default="${sf.maxPoll}"                description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="allowMissingFiles"      default="${sf.allowMissingFiles}"      description="Flag, if true, and file not found in the deployment file will succeed"/>
		<attribute name="replaceVarsFile"        default="${sf.replaceVarsFile}"        description="A file containing any variables that should be replaced before deployment"/>
		<attribute name="ignoreWarnings"         default="${sf.ignoreWarnings}"         description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="ignoreFile"             default="${sf.ignoreFile}"             description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="checkOnly"              default="${sf.checkOnly}"              description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"                default="${sf.logType}"                description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
        <attribute name="dryRun"                 default="${sf.dryRun}"                 description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="fastDeploy"             default="${sf.fastDeploy}"             description="If set to anything other than an empty string, will assume you want to run tests as denoted by classes annotated with @testClasses"/>
        <attribute name="dumpFiles"              default="${sf.dumpFiles}"              description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords"          default="${sf.showPasswords}"          description="When generating a build.xml, will contain the token/password used"/>
        <attribute name="xslDir"                 default="${sf.xslDir}"                 description="Directory containing XSLTs to apply"/>
		<attribute name="description"            default=""                             description="Comment regarding calling this macrodef"/>

		<sequential>
            <!--
            <rh-sfdc:createPackageXmlChildren property="foo" fileList="@{addFileList}" fileDelimiter="@{fileDelimiter}"/>
            <rh-sfdc:createPackageXmlChildren property="foo" fileList="@{removeFileList}" fileDelimiter="@{fileDelimiter}" isDestructiveChange="true"/>
            <fail/>
            -->

			<!--
				Define our temporary "scratch" area..
			-->
			<rh-util:property name="file-push.tmp.DIR" value="${solenopsis.temp.DIR}/file-push"/>
			<delete dir="${file-push.tmp.DIR}"/>
			<mkdir dir="${file-push.tmp.DIR}"/>

			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="file-push.USERNAME" webServicePassword="file-push.PASSWORD" url="file-push.URL" version="file-push.VERSION"/>

			<!--
				If there is nothing added, we'll just create an empty
				package.xml
			-->
			<rh-util:ifNotEqual arg1="@{addFileList}" arg2="@{fileDelimiter}">
				<rh-util:then>
                    <rh-sfdc:purge-ignores-refs env="@{masterEnv}"/>

					<!--
						Something to push, copy the files and create a good
						package.xml representing those files...

						This loop really stinks.  Have to do it this way because
						some file names may have spaces...the includes attribute
						on fileset assumes the delimiter is either a space or
						comma - so spaces in the file name are being seen as
						a delimiter...
					-->
					<rh-util:processList param="file-push.INCLUDE-FILE" list="@{addFileList}" listDelimiter="@{fileDelimiter}">
						<!--
							Hate this!  Only doing this since filelist spits out a warning in
							Ant 1.8.x if a file does not exist...
						-->
						<rh-util:ifFileExists file="${solenopsis.env.@{masterEnv}.HOME}/@{file-push.INCLUDE-FILE}-meta.xml">
							<rh-util:then>
								<copy todir="${file-push.tmp.DIR}">
									<filelist dir="${solenopsis.env.@{masterEnv}.HOME}">
										<file name="@{file-push.INCLUDE-FILE}"/>
										<file name="@{file-push.INCLUDE-FILE}-meta.xml"/>
									</filelist>
								</copy>
							</rh-util:then>
							<rh-util:else>
								<copy todir="${file-push.tmp.DIR}" failonerror="false">
									<filelist dir="${solenopsis.env.@{masterEnv}.HOME}">
										<file name="@{file-push.INCLUDE-FILE}"/>
									</filelist>
								</copy>
							</rh-util:else>
						</rh-util:ifFileExists>
					</rh-util:processList>

                    <rh-sfdc:createPackageXmlChildren property="file-push.PACKAGE" fileList="@{addFileList}" fileDelimiter="@{fileDelimiter}" version="${file-push.VERSION}"/>

                    <!--
					<rh-sfdc:xml-package property="file-push.PACKAGE" version="${file-push.VERSION}">
						<rh-sfdc:file-list-xml-types property="file-push.PACKAGE" fileList="@{addFileList}" fileDelimiter="@{fileDelimiter}"/>
					</rh-sfdc:xml-package>
                        -->
				</rh-util:then>

				<!--
					Ooops, no files to push - empty package.xml!
				-->
				<rh-util:else>
					<rh-sfdc:xml-package property="file-push.PACKAGE" version="${file-push.VERSION}"/>
				</rh-util:else>
			</rh-util:ifNotEqual>

			<echo message="${file-push.PACKAGE}" file="${file-push.tmp.DIR}/package.xml"/>

			<rh-util:ifNotEqual arg1="@{removeFileList}:@{removeFieldList}" arg2=":">
				<rh-util:then>
                    <rh-sfdc:createPackageXmlChildren property="file-push.DESTRUCTIVE-CHANGES" fileList="@{removeFileList}" fieldList="@{removeFieldList}" fileDelimiter="@{fileDelimiter}" version="${file-push.VERSION}"/>

                    <!--
					<rh-sfdc:xml-package property="file-push.DESTRUCTIVE-CHANGES" version="${file-push.VERSION}">
						<rh-sfdc:file-list-xml-types property="file-push.DESTRUCTIVE-CHANGES" fileList="@{removeFileList}" fileDelimiter="@{fileDelimiter}" members-all=""/>
					</rh-sfdc:xml-package>
                    -->

                    <echo message="${file-push.DESTRUCTIVE-CHANGES}" file="${file-push.tmp.DIR}/@{destructiveChangesFile}"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<!--
				Do variable replacements...
			-->
			<property file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties" prefix="solenopsis.deploy.env"/>

			<rh-util:ifNotEqual arg1="@{replaceVarsFile}" arg2="">
				<rh-util:then>
					<xmlproperty file="@{replaceVarsFile}" collapseAttributes="true" prefix="push"/>

					<rh-util:replaceVariables dir="${file-push.tmp.DIR}" prefix="push" description="Replace all variables"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<xmlproperty file="1.1/properties/sfdc_replace.xml" collapseAttributes="true" prefix="push"/>
            <rh-util:replaceVariables dir="${file-push.tmp.DIR}" prefix="push" description="Replace all variables"/>

			<ac:propertyselector property="file-push.credentials.replace.NAME" delimiter="," match="(solenopsis\.env\.@{dependentEnv}\.credentials\.)(\S+)" select="\2"/>
			<rh-util:processPropertyAsList property="file-push.credentials.replace.NAME" param="file-push.credentials.replace.VALUE" listDelimiter=",">
				<rh-util:property name="file-push.credentials.replace.TOKEN" value="@{file-push.credentials.replace.VALUE}"/>
				<rh-util:prependProperty name="file-push.credentials.replace.TOKEN" value="{"/>
				<rh-util:prependProperty name="file-push.credentials.replace.TOKEN" value="@"/>
				<rh-util:appendProperty name="file-push.credentials.replace.TOKEN" value="}"/>

				<rh-util:propertyDereference name="file-push.credentials.replace.REAL_VALUE" property="solenopsis.env.@{dependentEnv}.credentials.@{file-push.credentials.replace.VALUE}"/>

				<replace dir="${file-push.tmp.DIR}" includes="*/**" token="${file-push.credentials.replace.TOKEN}" value="${file-push.credentials.replace.REAL_VALUE}"/>
			</rh-util:processPropertyAsList>

			<rh-util:property name="file-push.DEPLOY_FILE" value="${file-push.tmp.DIR}/deploy.zip"/>

            <rh-util:find-value-in-files baseDir="${file-push.tmp.DIR}/classes"  key="(\s)*\*(\s)*@testClasses" valuesFound="file-push.TEST_CLASSES"/>
            <rh-util:find-value-in-files baseDir="${file-push.tmp.DIR}/triggers" key="(\s)*\*(\s)*@testClasses" valuesFound="file-push.TEST_TRIGGERS"/>

            <rh-sfdc:transformFiles srcDir="${file-push.tmp.DIR}" xslDir="@{xslDir}" operation="push"/>

            <loadfile property="file-push.RAW_IGNORE_FILE_CONTENTS" srcFile="@{ignoreFile}" failonerror="false"/>

            <ac:propertyregex property="file-push.IGNORE_FILE_CONTENTS" input="${file-push.RAW_IGNORE_FILE_CONTENTS}" regexp="\s" replace=""/>

            <!--
                Process the implicit ignores...
            -->
            <rh-sfdc:processImplicitIgnores dependentEnv="@{dependentEnv}" dir="${file-push.tmp.DIR}" maxPoll="@{maxPoll}"/>

			<!--
				If an excludes file is passed in, use that for the zip task, otherwise,
				just call out to zip without it.  Unfortunately, zip complains if one
				presents an empty string...
			-->
            <rh-util:ifNotEqual arg1="${file-push.IGNORE_FILE_CONTENTS}" arg2="">
				<rh-util:then>
					<zip destfile="${file-push.DEPLOY_FILE}" basedir="${file-push.tmp.DIR}" excludesfile="@{ignoreFile}" level="9"/>

                    <pathconvert property="file-push.PATH">
                        <fileset dir="${file-push.tmp.DIR}" includesFile="@{ignoreFile}"/>
                    </pathconvert>

                    <!--
                        Make sure we did NOT try to push out a file that was to not be included!!!
                    -->
                    <rh-util:find-files-in-zip-file zipFile="${file-push.DEPLOY_FILE}" fileList="${file-push.PATH}" baseDir="${file-push.tmp.DIR}" fileDelimiter="@{fileDelimiter}" filesFound="file-push.FILES_FOUND"/>

                    <rh-util:ifNotEqual arg1="${file-push.FILES_FOUND}" arg2="">
                        <rh-util:then>
                            <fail message="You are attempting to push file(s) that are to be ignored:  ${file-push.FILES_FOUND}"/>
                        </rh-util:then>
                    </rh-util:ifNotEqual>
				</rh-util:then>

				<rh-util:else>
					<zip destfile="${file-push.DEPLOY_FILE}" basedir="${file-push.tmp.DIR}" level="9"/>
				</rh-util:else>
			</rh-util:ifNotEqual>


			<echo>

                Processing:                [@{dependentEnv}]

                Requested Push:            [@{addFileList}]
                Requested Remove:          [@{removeFileList}]

                Destructive changes file:  [@{destructiveChangesFile}]

                Ignoring:                  [${file-push.PATH}]

                URL:                       [${file-push.URL}]
                API:                       [${file-push.VERSION}]
                Check only:                [@{checkOnly}]

                Run all tests:             [@{runAllTests}]
                Test level:                [@{testLevel}]

                Jar:                       [${sf.migrationToolJar}]

                @{fastDeploy}

			</echo>

            <rh-util:ifDefinedValue value="@{fastDeploy}">
                <rh-util:then>
                    <rh-sfdc:executeRunTests masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" zipFile="${file-push.DEPLOY_FILE}" trace="@{trace}" maxPoll="@{maxPoll}" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}" testClasses="${file-push.TEST_CLASSES} ${file-push.TEST_TRIGGERS}" delimiter=" " dryRun="@{dryRun}"/>
                </rh-util:then>
                <rh-util:else>
                    <rh-util:ifEqual arg1="@{dryRun}" arg2="">
                        <rh-util:then>
                            <rh-sfdc:generateDeployXml dir="${file-push.tmp.DIR}" antJar="${sf.migrationToolJar}" apiVersion="${file-push.VERSION}" username="${file-push.USERNAME}" password="${file-push.PASSWORD}" serverurl="${file-push.URL}" zipFile ="${file-push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

                            <rh-util:ifEqual arg1="@{testLevel}" arg2="">
                                <rh-util:then>
                                    <sf:deploy username="${file-push.USERNAME}" password="${file-push.PASSWORD}" serverurl="${file-push.URL}" zipFile="${file-push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}"/>
                                </rh-util:then>
                                <rh-util:else>
                                    <sf:deploy username="${file-push.USERNAME}" password="${file-push.PASSWORD}" serverurl="${file-push.URL}" zipFile="${file-push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" testLevel="@{testLevel}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}"/>
                                </rh-util:else>
                            </rh-util:ifEqual>
                        </rh-util:then>

                        <rh-util:else>
                            <echo message="Dry run set to [@{dryRun}] - not deploying!"/>
                        </rh-util:else>
                    </rh-util:ifEqual>
                </rh-util:else>
            </rh-util:ifDefinedValue>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="computeFieldDiffs" uri="http://www.redhat.com/sfdc" language="beanshell" description="Generate a build.xml for a build retrieve">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="dir"/>
        <attribute name="compareDir"/>
        <attribute name="property"/>

		<![CDATA[
            import java.io.FilenameFilter;
            import java.io.FileReader;
            import java.util.Arrays;
            import java.util.List;
            import java.util.Set;
            import java.util.TreeSet;
            import org.xml.sax.InputSource;
            import org.w3c.dom.Node;
            import org.w3c.dom.NodeList;
            import javax.xml.xpath.XPath;
            import javax.xml.xpath.XPathConstants;
            import javax.xml.xpath.XPathFactory;

            // Data to apply with XPath.
            class ApplyXpath {
                String applyDir;
                String extension;
                String typeName;
                String xpath;

                ApplyXpath(String applyDir, String extension, String typeName, String xpath) {
                    this.applyDir = applyDir;
                    this.extension = extension;
                    this.typeName = typeName;
                    this.xpath = xpath;
                }

                public String toString() {
                    StringBuilder sb = new StringBuilder();

                    sb.append("applyDir  = [").append(applyDir).append("]  ");
                    sb.append("extension = [").append(extension).append("]  ");
                    sb.append("typeName  = [").append(typeName).append("]  ");
                    sb.append("xpath     = [").append(xpath).append("]\n");

                    return sb.toString();
                }
            }

            // Only use certain files.
            class FileFilter implements FilenameFilter {
                String extension;

                FileFilter(String extension) {
                    this.extension = extension;
                }

                FileFilter(ApplyXpath applyXpath) {
                    this(applyXpath.extension);
                }

                public boolean accept(File dir, String name) {
                    return name.endsWith(extension);
                }
            }


            // Returns a list of all the XPaths we support to perform
            // field level diffs.
            List getApplyXpaths() {
                List retVal = new ArrayList();

                retVal.add(new ApplyXpath("objects", "object", "ActionOverride", "/*[local-name() = 'CustomObject']/*[local-name() = 'actionOverrides']/*[local-name() = 'actionName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "BusinessProcess", "/*[local-name() = 'CustomObject']/*[local-name() = 'businessProcesses']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "CustomField", "/*[local-name() = 'CustomObject']/*[local-name() = 'fields']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "ListView", "/*[local-name() = 'CustomObject']/*[local-name() = 'listViews']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "NamedFilter", "/*[local-name() = 'CustomObject']/*[local-name() = 'namedFilters']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "RecordType", "/*[local-name() = 'CustomObject']/*[local-name() = 'recordTypes']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "ValidationRule", "/*[local-name() = 'CustomObject']/*[local-name() = 'validationRules']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("objects", "object", "WebLink", "/*[local-name() = 'CustomObject']/*[local-name() = 'webLinks']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("workflows", "workflow", "WorkflowAlert", "/*[local-name() = 'Workflow']/*[local-name() = 'alerts']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("workflows", "workflow", "WorkflowFieldUpdate", "/*[local-name() = 'Workflow']/*[local-name() = 'fieldUpdates']/*[local-name() = 'fullName']/text()"));
                retVal.add(new ApplyXpath("workflows", "workflow", "WorkflowRule", "/*[local-name() = 'Workflow']/*[local-name() = 'rules']/*[local-name() = 'fullName']/text()"));

                return retVal;
            }

            // -------------------------------------------------------------

            File getCompareFile(File compareDir, String fileName) {
                return new File(compareDir, fileName);
            }

            File getCompareFile(File file, File compareDir, ApplyXpath applyXpath) {
                return getCompareFile(new File(compareDir, applyXpath.applyDir), file.getName());
            }

            // -------------------------------------------------------------

            boolean isCompareFileFound(File file, File compareDir, ApplyXpath applyXpath) {
                return getCompareFile(file, compareDir, applyXpath).exists();
            }

            // -------------------------------------------------------------

            NodeList evaluate(XPath xpath, InputSource inputSource, String xpathStr) {
                return xpath.evaluate(xpathStr, inputSource, XPathConstants.NODESET);
            }

            NodeList evaluate(XPath xpath, FileReader fileReader, String xpathStr) {
                NodeList retVal = evaluate(xpath, new InputSource(fileReader), xpathStr);
                fileReader.close();

                return retVal;
            }

            NodeList evaluate(XPath xpath, File file, String xpathStr) {
                return evaluate(xpath, new FileReader(file), xpathStr);
            }

            NodeList evaluate(XPath xpath, File file, ApplyXpath applyXpath) {
                return evaluate(xpath, file, applyXpath.xpath);
            }

            // -------------------------------------------------------------

            Set asTextSet(NodeList nodeList) {
                Set retVal = new TreeSet();

                for (int index = 0; index < nodeList.getLength(); index++ ) {
                    retVal.add(nodeList.item(index).getNodeValue());
                }

                return retVal;
            }

            // -------------------------------------------------------------

            String computeBaseName(String file) {
                return file.substring(0, file.lastIndexOf('.'));
            }

            String computeBaseName(File file) {
                return computeBaseName(file.getName());
            }

            // -------------------------------------------------------------

            void denoteDiffs(StringBuilder sb, File file, Set missingValues, String typeName) {
                for (String text : missingValues) {
                    sb.append(typeName).append('=').append(computeBaseName(file)).append('.').append(text).append(':');
                }
            }

            // -------------------------------------------------------------

            void compareNodes(StringBuilder sb, File file, NodeList nodeList, NodeList compareNodeList, String typeName) {
                Set values = asTextSet(nodeList);
                values.removeAll(asTextSet(compareNodeList));

                denoteDiffs(sb, file, values, typeName);
            }

            void compareNodes(StringBuilder sb, File file, NodeList nodeList, NodeList compareNodeList, ApplyXpath applyXpath) {
                compareNodes(sb, file, nodeList, compareNodeList, applyXpath.typeName);
            }

            // -------------------------------------------------------------

            void compareXpath(XPath xpath, StringBuilder sb, File file, File compareDir, ApplyXpath applyXpath) {
                if (!isCompareFileFound(file, compareDir, applyXpath)) {
                    System.out.println("Skipping [" + file + "]");
                    return;
                }

                compareNodes(sb, file, evaluate(xpath, file, applyXpath), evaluate(xpath, getCompareFile(file, compareDir, applyXpath), applyXpath), applyXpath);
            }

            // -------------------------------------------------------------

            Set convertToSet(Set set, List contents) {
                set.addAll(contents);

                return set;
            }


            Set convertToSet(List contents) {
                return convertToSet(new TreeSet(), contents);
            }

            // -------------------------------------------------------------

            void applyXpath(XPath xpath, StringBuilder sb, Set dirContents, File compareDir, ApplyXpath applyXpath) {
                if (null == dirContents) {
                    return;
                }

                for (File dir : dirContents) {
                    compareXpath(xpath, sb, dir, compareDir, applyXpath);
                }
            }

            void applyXpath(XPath xpath, StringBuilder sb, List dirContents, File compareDir, ApplyXpath applyXpath) {
                applyXpath(xpath, sb, convertToSet(dirContents), compareDir, applyXpath);
            }

            void applyXpath(XPath xpath, StringBuilder sb, File[] dirContents, File compareDir, ApplyXpath applyXpath) {
                applyXpath(xpath, sb, Arrays.asList(dirContents), compareDir, applyXpath);
            }

            void applyXpath(FileFilter filter, XPath xpath, StringBuilder sb, File dir, File compareDir, ApplyXpath applyXpath) {
                applyXpath(xpath, sb, new File(dir, applyXpath.applyDir).listFiles(filter), compareDir, applyXpath);
            }

            void applyXpath(XPath xpath, StringBuilder sb, File dir, File compareDir, ApplyXpath applyXpath) {
                applyXpath(new FileFilter(applyXpath), xpath, sb, dir, compareDir, applyXpath);
            }

            // -------------------------------------------------------------

            String applyXpaths(StringBuilder sb, File dir, File compareDir, List applyXpathList) {
                for (ApplyXpath applyXpath : applyXpathList) {
                    applyXpath(XPathFactory.newInstance().newXPath(), sb, dir, compareDir, applyXpath);
                }

                return sb.toString();
            }

            String applyXpaths(String dir, String compareDir, List applyXpathList) {
                return applyXpaths(new StringBuilder(), new File(dir), new File(compareDir), applyXpathList);
            }

            // -------------------------------------------------------------

            project.setProperty(attributes.get("property"), applyXpaths(attributes.get("dir"), attributes.get("comparedir"), getApplyXpaths()));
        ]]>
	</scriptdef>

    <scriptdef name="ensureMetadataPairs" uri="http://www.redhat.com/sfdc" language="beanshell" description="Ensure a metadata file has a corresponding file">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="data"/>
        <attribute name="property"/>
        <attribute name="delimiter"/>

		<![CDATA[
            // -------------------------------------------------------------

            Set convertToSet(String data, String delimiter) {
                Set retVal = new TreeSet();

                for (String val : data.split(delimiter)) {
                    retVal.add(val);
                }

                return retVal;
            }

            // -------------------------------------------------------------

            boolean isMetadata(String val) {
                return val.endsWith("-meta.xml");
            }

            boolean isNoMatchingPair(Set data, String val) {
                return isMetadata(val) && !data.contains(val.replace("-meta.xml", ""));
            }

            // -------------------------------------------------------------

            boolean isData(String data) {
                return null != data && !("".equals(data.trim()));
            }

            // -------------------------------------------------------------

            StringBuilder computePairs(Set data, String delimiter, StringBuilder sb) {
                for (String val : data) {
                    sb.append(val).append(delimiter);

                    if (isNoMatchingPair(data, val)) {
                        sb.append(val.replace("-meta.xml", "")).append(delimiter);
                    }
                }

                return sb;
            }

            // -------------------------------------------------------------

            String computePairs(String data, String delimiter) {
                if (!isData(data)) {
                    return "";
                }

                return computePairs(convertToSet(data, delimiter), delimiter, new StringBuilder()).toString();
            }
                
            // -------------------------------------------------------------

            project.setProperty(attributes.get("property"), computePairs(attributes.get("data"), attributes.get("delimiter")));
        ]]>
	</scriptdef>

    <macrodef name="delta-push" backtrace="true" uri="http://www.redhat.com/sfdc" description="This pushes a list of files from @{masterEnv} to @{dependentEnv} based on added/modified files">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to push"/>
		<attribute name="fileDelimiter"      default="${path.separator}"           description="A list of files to push out to @{dependentEnv}"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="runAllTests"        default="${sf.runAllTests}"           description="Flag, if true all tests will be run upon deployment"/>
        <attribute name="testLevel"          default="${sf.testLevel}"              description="Denotes the test level to run upon deployment NoTestRun, RunLocalTests, RunAllTestsInOrg"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="allowMissingFiles"  default="${sf.allowMissingFiles}"     description="Flag, if true, and file not found in the deployment file will succeed"/>
		<attribute name="replaceVarsFile"    default="${sf.replaceVarsFile}"       description="A file containing any variables that should be replaced before deployment"/>
		<attribute name="ignoreWarnings"     default="${sf.ignoreWarnings}"        description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="ignoreFile"         default="${sf.ignoreFile}"            description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="checkOnly"          default="${sf.checkOnly}"             description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"            default="${sf.logType}"               description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
        <attribute name="dryRun"             default="${sf.dryRun}"                description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="fastDeploy"         default="${sf.fastDeploy}"            description="If set to anything other than an empty string, will assume you want to run tests as denoted by classes annotated with @testClasses"/>
        <attribute name="xslDir"             default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

        <sequential>
            <rh-util:ifUndefinedValue value="${solenopsis.env.@{dependentEnv}.HOME}">
                <rh-util:then>
                    <fail>
                        Please define [@{dependentEnv}] in solenopsis.ENVIRONMENTS!!!
                    </fail>
                </rh-util:then>
            </rh-util:ifUndefinedValue>

            <rh-util:dirDiff src="${solenopsis.env.@{masterEnv}.HOME}" dest="${solenopsis.env.@{dependentEnv}.HOME}" addProperty="delta-push.ADD" modProperty="delta-push.MOD" delProperty="delta-push.DEL" delimiter="@{fileDelimiter}"/>

            <rh-sfdc:ensureMetadataPairs data="${delta-push.MOD}" property="delta-push.MOD" delimiter="@{fileDelimiter}"/>

            <rh-sfdc:computeFieldDiffs dir="${solenopsis.env.@{dependentEnv}.HOME}" compareDir="${solenopsis.env.@{masterEnv}.HOME}" property="delta-push.REMOVE_FIELDS"/>

            <rh-sfdc:file-push masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" addFileList="${delta-push.ADD}@{fileDelimiter}${delta-push.MOD}" removeFileList="${delta-push.DEL}" removeFieldList="${delta-push.REMOVE_FIELDS}" fileDelimiter="@{fileDelimiter}" trace="@{trace}" runAllTests="@{runAllTests}" testLevel="@{testLevel}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" replaceVarsFile="@{replaceVarsFile}" ignoreWarnings="@{ignoreWarnings}" ignoreFile="@{ignoreFile}" checkOnly="@{checkOnly}" logType="@{logType}" dryRun="@{dryRun}" fastDeploy="@{fastDeploy}" xslDir="@{xslDir}"/>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="git-destructive-push" backtrace="true" uri="http://www.redhat.com/sfdc" description="This pushes files that have changed in a git repo.  It assumed masterEnv is a git repo">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to push"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="runAllTests"        default="${sf.runAllTests}"           description="Flag, if true all tests will be run upon deployment"/>
        <attribute name="testLevel"          default="${sf.testLevel}"              description="Denotes the test level to run upon deployment NoTestRun, RunLocalTests, RunAllTestsInOrg"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="allowMissingFiles"  default="${sf.allowMissingFiles}"     description="Flag, if true, and file not found in the deployment file will succeed"/>
		<attribute name="ignoreWarnings"     default="${sf.ignoreWarnings}"        description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="checkOnly"          default="${sf.checkOnly}"             description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"            default="${sf.logType}"               description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
        <attribute name="dryRun"             default="${sf.dryRun}"                description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="xslDir"             default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:git-status addProperty="git-destructive-push.ADD-FILES" modProperty="git-destructive-push.MOD-FILES" delProperty="git-destructive-push.DEL-FILES" dir="${solenopsis.env.@{masterEnv}.HOME}" delimiter=":" ignorePattern="meta.xml"/>

			<rh-util:ifNotEqual arg1="${git-destructive-push.ADD-FILES}${git-destructive-push.MOD-FILES}${git-destructive-push.DEL-FILES}" arg2="">
				<rh-util:then>
                    <rh-sfdc:file-push masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" addFileList="${git-destructive-push.ADD-FILES}:${git-destructive-push.MOD-FILES}" removeFileList="${git-destructive-push.DEL-FILES}" fileDelimiter="${path.separator}" trace="@{trace}" runAllTests="@{runAllTests}" testLevel="@{testLevel}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}" dryRun="@{dryRun}" xslDir="@{xslDir}"/>
				</rh-util:then>

				<rh-util:else>
					<echo message="No Git changes to push"/>
				</rh-util:else>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="git-push" backtrace="true" uri="http://www.redhat.com/sfdc" description="This pushes files that have changed in a git repo.  It assumed masterEnv is a git repo">
		<attribute name="masterEnv"          default="${solenopsis.env.MASTER}"    description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"       default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to push"/>
		<attribute name="trace"              default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="runAllTests"        default="${sf.runAllTests}"           description="Flag, if true all tests will be run upon deployment"/>
        <attribute name="testLevel"          default="${sf.testLevel}"             description="Denotes the test level to run upon deployment NoTestRun, RunLocalTests, RunAllTestsInOrg"/>
		<attribute name="maxPoll"            default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="allowMissingFiles"  default="${sf.allowMissingFiles}"     description="Flag, if true, and file not found in the deployment file will succeed"/>
		<attribute name="checkOnly"          default="${sf.checkOnly}"             description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"            default="${sf.logType}"               description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
		<attribute name="ignoreWarnings"     default="${sf.ignoreWarnings}"        description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
        <attribute name="dryRun"             default="${sf.dryRun}"                description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="xslDir"             default="${sf.xslDir}"                description="Directory containing XSLTs to apply"/>
		<attribute name="description"        default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-util:git-status addProperty="git-push.ADD-FILES" modProperty="git-push.MOD-FILES" delProperty="git-push.DEL-FILES" dir="${solenopsis.env.@{masterEnv}.HOME}" delimiter=":" ignorePattern="meta.xml"/>

			<rh-util:ifNotEqual arg1="${git-destructive-push.ADD-FILES}${git-destructive-push.MOD-FILES}" arg2="">
				<rh-util:then>
                    <rh-sfdc:file-push masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" addFileList="${git-push.ADD-FILES}:${git-push.MOD-FILES}" fileDelimiter="${path.separator}" trace="@{trace}" runAllTests="@{runAllTests}" testLevel="@{testLevel}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}" dryRun="@{dryRun}" xslDir="@{xslDir}"/>
				</rh-util:then>

				<rh-util:else>
					<echo message="No Git changes to push"/>
				</rh-util:else>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="push" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will push the master to SFDC dependent environments - its is an additive push">
		<attribute name="masterEnv"              default="${solenopsis.env.MASTER}"     description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"           default="${solenopsis.env.DEPENDENT}"  description="The dependent environment from which to push"/>
		<attribute name="destructiveChanges"     default=""                             description="If not empty, the value is for destructiveChanges.xml"/>
        <attribute name="destructiveChangesFile" default="${sf.destructiveChangesFile}" description="The file name to call destructiveChanges.xml"/>
		<attribute name="packageFile"            default="${sf.packageFile}"            description="A user supplied package.xml to use for deployment"/>
		<attribute name="trace"                  default="${sf.trace}"                  description="Trace the call to SFDC on deploy"/>
		<attribute name="runAllTests"            default="${sf.runAllTests}"            description="Flag, if true all tests will be run upon deployment"/>
        <attribute name="testLevel"              default="${sf.testLevel}"              description="Denotes the test level to run upon deployment NoTestRun, RunLocalTests, RunAllTestsInOrg"/>
		<attribute name="maxPoll"                default="${sf.maxPoll}"                description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="allowMissingFiles"      default="${sf.allowMissingFiles}"      description="Flag, if true, and file not found in the deployment file will succeed"/>
		<attribute name="ignoreWarnings"         default="${sf.ignoreWarnings}"         description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="replaceVarsFile"        default="${sf.replaceVarsFile}"        description="A file containing any variables that should be replaced before deployment"/>
		<attribute name="ignoreFile"             default="${sf.ignoreFile}"             description="A file containing patterns/file names of what to exclude when deploying"/>
		<attribute name="checkOnly"              default="${sf.checkOnly}"              description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"                default="${sf.logType}"                description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
        <attribute name="dryRun"                 default="${sf.dryRun}"                 description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="dumpFiles"              default="${sf.dumpFiles}"              description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords"          default="${sf.showPasswords}"          description="When generating a build.xml, will contain the token/password used"/>
        <attribute name="xslDir"                 default="${sf.xslDir}"                 description="Directory containing XSLTs to apply"/>
		<attribute name="description"            default=""                             description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="push.USERNAME" webServicePassword="push.PASSWORD" url="push.URL" version="push.VERSION"/>

			<!--
				Were we supplied a user defined package.xml?
			-->
			<rh-util:ifEqual arg1="@{packageFile}" arg2="">
				<rh-util:then>
					<echo message="Generating package.xml"/>

					<rh-sfdc:xml-package property="push.PACKAGE" version="${push.VERSION}">
						<rh-sfdc:members-xml-types property="push.PACKAGE"/>
						<rh-sfdc:nonfolders-members-xml-types property="push.PACKAGE"/>

						<rh-sfdc:folders-members-xml-types property="push.PACKAGE" env="@{masterEnv}"/>
					</rh-sfdc:xml-package>
				</rh-util:then>

				<rh-util:else>
					<rh-util:ifFileExists file="@{packageFile}">
						<rh-util:then>
							<echo message="User defined package file being used [@{packageFile}]"/>

							<loadfile property="push.PACKAGE" srcFile="@{packageFile}"/>
						</rh-util:then>
						
						<rh-util:else>
							<fail message="Cannot load package file [@{packageFile}] - it does not exist!"/>
						</rh-util:else>
					</rh-util:ifFileExists>
				</rh-util:else>
			</rh-util:ifEqual>

            <rh-sfdc:purge-ignores-refs env="@{masterEnv}"/>

			<!--
				Define our temporary "scratch" area..
			-->
			<rh-util:property name="push.tmp.DIR" value="${solenopsis.temp.DIR}/push"/>
			<delete dir="${push.tmp.DIR}"/>
			<mkdir dir="${push.tmp.DIR}"/>

			<rh-util:ifNotSet property="sf.filesContain">
				<rh-util:then>
					<copy todir="${push.tmp.DIR}">
                        <fileset dir="${solenopsis.env.@{masterEnv}.HOME}" includes="**/*" excludes="${push.flow.ignore}"/>
					</copy>
				</rh-util:then>

				<rh-util:else>
					<echo message="Looking for [${sf.filesContain}]"/>
					<rh-util:findFilesContaining dir="${solenopsis.env.@{masterEnv}.HOME}" property="push.SPECIFIC_FILES" value="${sf.filesContain}" delimiter=",">
						<include name="**/*"/>
					</rh-util:findFilesContaining>

					<ac:var name="push.ALL-META_FILES" unset="true"/>
					<rh-util:processList param="push.META-FILE"  list="${push.SPECIFIC_FILES}" listDelimiter=",">
						<rh-util:appendProperty name="push.ALL-META-FILES" value="@{push.META-FILE}-meta.xml,"/>
					</rh-util:processList>

					<rh-util:copyFiles fileList="${push.SPECIFIC_FILES},${push.ALL-META-FILES}" root="${solenopsis.env.@{masterEnv}.HOME}" destDir="${push.tmp.DIR}" delimiter=","/>
				</rh-util:else>
			</rh-util:ifNotSet>

			<echo message="${push.PACKAGE}" file="${push.tmp.DIR}/package.xml"/>

			<!--
				May be pushing out destructiveChanges...
			-->
			<rh-util:ifNotEqual arg1="@{destructiveChanges}" arg2="">
				<rh-util:then>
                    <echo message="@{destructiveChanges}" file="${push.tmp.DIR}/@{destructiveChangesFile}"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<!--
				Do variable replacements...
			-->
			<property file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties" prefix="solenopsis.deploy.env"/>

			<rh-util:ifNotEqual arg1="@{replaceVarsFile}" arg2="">
				<rh-util:then>
					<xmlproperty file="@{replaceVarsFile}" collapseAttributes="true" prefix="push"/>

					<rh-util:replaceVariables dir="${push.tmp.DIR}" prefix="push" description="Replace all variables"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<xmlproperty file="1.1/properties/sfdc_replace.xml" collapseAttributes="true" prefix="push"/>
            <rh-util:replaceVariables dir="${push.tmp.DIR}" prefix="push" description="Replace all variables"/>

			<ac:propertyselector property="push.credentials.replace.NAME" delimiter="," match="(solenopsis\.env\.@{dependentEnv}\.credentials\.)(\S+)" select="\2"/>
			<rh-util:processPropertyAsList property="push.credentials.replace.NAME" param="push.credentials.replace.VALUE" listDelimiter=",">
				<rh-util:property name="push.credentials.replace.TOKEN" value="@{push.credentials.replace.VALUE}"/>
				<rh-util:prependProperty name="push.credentials.replace.TOKEN" value="{"/>
				<rh-util:prependProperty name="push.credentials.replace.TOKEN" value="@"/>
				<rh-util:appendProperty name="push.credentials.replace.TOKEN" value="}"/>

				<rh-util:propertyDereference name="push.credentials.replace.REAL_VALUE" property="solenopsis.env.@{dependentEnv}.credentials.@{push.credentials.replace.VALUE}"/>

				<replace dir="${push.tmp.DIR}" includes="*/**" token="${push.credentials.replace.TOKEN}" value="${push.credentials.replace.REAL_VALUE}"/>
			</rh-util:processPropertyAsList>

            <!--
                Process the implicit ignores...
            -->
            <rh-sfdc:processImplicitIgnores dependentEnv="@{dependentEnv}" dir="${push.tmp.DIR}" maxPoll="@{maxPoll}"/>

			<!--
				Zip it up...
			-->
			<rh-util:property name="push.DEPLOY_FILE" value="${push.tmp.DIR}/deploy.zip"/>

			<!--
				If an excludes file is passed in, use that for the zip task, otherwise,
				just call out to zip without it.  Unfortunately, zip complains if one
				presents an empty string...
			-->
			<rh-util:ifNotEqual arg1="@{ignoreFile}" arg2="">
				<rh-util:then>
					<zip destfile="${push.DEPLOY_FILE}" basedir="${push.tmp.DIR}" excludesfile="@{ignoreFile}" level="9"/>
				</rh-util:then>

				<rh-util:else>
					<zip destfile="${push.DEPLOY_FILE}" basedir="${push.tmp.DIR}" level="9"/>
				</rh-util:else>
			</rh-util:ifNotEqual>

			<echo>

                Processing:                [@{dependentEnv}]

                URL:                       [${push.URL}]
                API:                       [${push.VERSION}]
                Destructive changes file:  [@{destructiveChangesFile}]
                Check only:                [@{checkOnly}]

                Rule all tests:            [@{runAllTests}]
                Test level:                [@{testLevel}]

                Jar:                       [${sf.migrationToolJar}]

			</echo>

            <rh-sfdc:generateDeployXml dir="${push.tmp.DIR}" antJar="${sf.migrationToolJar}" apiVersion="${push.VERSION}" username="${push.USERNAME}" password="${push.PASSWORD}" serverurl="${push.URL}" zipFile ="${push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

            <rh-sfdc:transformFiles srcDir="${push.tmp.DIR}" xslDir="@{xslDir}" operation="push"/>

            <rh-util:ifEqual arg1="@{dryRun}" arg2="">
                <rh-util:then>
                    <rh-util:ifEqual arg1="@{testLevel}" arg2="">
                        <rh-util:then>
                            <sf:deploy username="${push.USERNAME}" password="${push.PASSWORD}" serverurl="${push.URL}" zipFile="${push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" logType="@{logType}" checkOnly="@{checkOnly}" ignoreWarnings="@{ignoreWarnings}"/>
                        </rh-util:then>
                        <rh-util:else>
                            <sf:deploy username="${push.USERNAME}" password="${push.PASSWORD}" serverurl="${push.URL}" zipFile="${push.DEPLOY_FILE}" trace="@{trace}" runAllTests="@{runAllTests}" testLevel="@{testLevel}" maxPoll="@{maxPoll}" allowMissingFiles="@{allowMissingFiles}" logType="@{logType}" checkOnly="@{checkOnly}" ignoreWarnings="@{ignoreWarnings}"/>
                        </rh-util:else>
                    </rh-util:ifEqual>
                </rh-util:then>

                <rh-util:else>
                    <echo message="Dry run set to [@{dryRun}] - not deploying!"/>
                </rh-util:else>
            </rh-util:ifEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="computeTestRunAttributes" uri="http://www.redhat.com/sfdc" language="beanshell" description="Do the actual cleaning">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="apiVersion"/>
        <attribute name="testClasses"/>
        <attribute name="property"/>

		<![CDATA[
            Double api = new Double(attributes.get("apiversion"));

            if (api > 33.0) {
                // Test classes are computed with a space.
                if (null == attributes.get("testclasses") || "@{testClasses}".equals(attributes.get("testclasses")) || " ".equals((attributes.get("testclasses")))) {
                    project.setProperty(attributes.get("property"), "testLevel='RunLocalTests'");
                } else {
                    project.setProperty(attributes.get("property"), "testLevel='RunSpecifiedTests'");
                }
            } else {
                project.setProperty(attributes.get("property"), "");
            }
		]]>
	</scriptdef>

	<macrodef name="executeRunTests" backtrace="true" uri="http://www.redhat.com/sfdc" description="Execute dependent env run tests">
		<attribute name="masterEnv"      default="${solenopsis.env.MASTER}"    description="The environment who has the test classes to run"/>
		<attribute name="dependentEnv"   default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to run tests"/>
        <attribute name="zipFile"                                              description="The file to deploy"/>
		<attribute name="trace"          default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"        default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="ignoreWarnings" default="${sf.ignoreWarnings}"        description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="checkOnly"      default="${sf.checkOnly}"             description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"        default="${sf.logType}"               description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
		<attribute name="testClasses"    default="${sf.testClasses}"           description="The test classes to run"/>
        <attribute name="delimiter"      default=","                           description="Test class delimiter"/>
        <attribute name="dryRun"         default="${sf.dryRun}"                description="If set to anything other than an empty string, will assume you do not want to deploy"/>
		<attribute name="description"    default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-sfdc:compute-env-values env="@{dependentEnv}" username="executeRunTests.USERNAME" webServicePassword="executeRunTests.PASSWORD" url="executeRunTests.URL" version="executeRunTests.VERSION" generate-tests="executeRunTests.GENERATE_TESTS"/>

            <rh-util:property name="executeRunTests.tmp.DIR" value="${solenopsis.temp.DIR}/executeRunTests"/>
            <delete dir="${executeRunTests.tmp.DIR}"/>
            <mkdir dir="${executeRunTests.tmp.DIR}"/>

            <echo>

                Processing:   [@{dependentEnv}]

                URL:          [${executeRunTests.URL}]
                API:          [${executeRunTests.VERSION}]

                Jar:          [${sf.migrationToolJar}]

                Test Classes: [@{testClasses}]

            </echo>

            <rh-util:ifEqual arg1=" " arg2="@{testClasses}">
                <rh-util:then>
                    <echo>
                        WARNING:  No test classes provided!
                    </echo>
                </rh-util:then>
            </rh-util:ifEqual>

            <ac:var name="sfdc_util.executeRunTests.BUILD" unset="true"/>
            <rh-sfdc:computeTestRunAttributes apiVersion="${executeRunTests.VERSION}" testClasses="@{testClasses}" property="executeRunTests.ATTRIBUTES"/>

            <rh-util:xmlStartElement property="sfdc_util.executeRunTests.BUILD" name="project" attributes="xmlns:sf='antlib:com.salesforce' xmlns:ac='http://ant-contrib.sourceforge.net'" elementDelimiter="${line.separator}"/>
                <rh-util:xmlStartElement property="sfdc_util.executeRunTests.BUILD" name="taskdef" attributes="resource='com/salesforce/antlib.xml' uri='antlib:com.salesforce'" elementDelimiter="${line.separator}"/>
                    <rh-util:xmlStartElement property="sfdc_util.executeRunTests.BUILD" name="classpath" elementDelimiter="${line.separator}"/>
                        <rh-util:xmlStartElement property="sfdc_util.executeRunTests.BUILD" name="fileset" attributes="file='${sf.migrationToolJar}'" elementDelimiter="${line.separator}"/>
                        <rh-util:xmlEndElement property="sfdc_util.executeRunTests.BUILD" name="fileset" elementDelimiter="${line.separator}"/>
                    <rh-util:xmlEndElement  property="sfdc_util.executeRunTests.BUILD" name="classpath" elementDelimiter="${line.separator}"/>
                <rh-util:xmlEndElement property="sfdc_util.executeRunTests.BUILD" name="taskdef" elementDelimiter="${line.separator}"/>

                <rh-util:xmlStartElement property="sfdc_util.executeRunTests.BUILD" name="sf:deploy" attributes="username='${executeRunTests.USERNAME}' password='${executeRunTests.PASSWORD}' serverurl='${executeRunTests.URL}' zipFile='@{zipFile}' trace='@{trace}' maxPoll='@{maxPoll}' allowMissingFiles='true' ignoreWarnings='@{ignoreWarnings}' checkOnly='@{checkOnly}' logType='@{logType}' runAllTests='false' ${executeRunTests.ATTRIBUTES}" elementDelimiter="${line.separator}"/>
                    <rh-util:ifNotEqual arg1=" " arg2="@{testClasses}">
                        <rh-util:then>
                            <rh-util:processList param="executeRunTests.TEST" list="@{testClasses}" listDelimiter="@{delimiter}">
                                <rh-util:baseName property="executeRunTests.BASENAME" file="@{executeRunTests.TEST}" suffix=".cls"/>
                                <rh-util:xmlElement property="sfdc_util.executeRunTests.BUILD" name="runTest" value="${executeRunTests.BASENAME}" elementDelimiter="${line.separator}"/>
                            </rh-util:processList>
                        </rh-util:then>
                    </rh-util:ifNotEqual>
                <rh-util:xmlEndElement property="sfdc_util.executeRunTests.BUILD" name="sf:deploy" elementDelimiter="${line.separator}"/>
            <rh-util:xmlEndElement property="sfdc_util.executeRunTests.BUILD" name="project" elementDelimiter="${line.separator}"/>

            <echo file="${executeRunTests.tmp.DIR}/runtests.xml" message="${sfdc_util.executeRunTests.BUILD}"/>

            <!-- Escape any ampersands -->
            <replace file="${executeRunTests.tmp.DIR}/runtests.xml">
                <replacetoken><![CDATA[&]]></replacetoken>
                <replacevalue><![CDATA[&amp;]]></replacevalue>
            </replace>

            <rh-util:ifEqual arg1="@{dryRun}" arg2="">
                <rh-util:then>
                    <ant antfile="${executeRunTests.tmp.DIR}/runtests.xml"/>
                </rh-util:then>

                <rh-util:else>
                    <echo message="Dry run set to [@{dryRun}] - not deploying!"/>
                </rh-util:else>
            </rh-util:ifEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="computeTestLevel" uri="http://www.redhat.com/sfdc" language="beanshell" description="Do the actual cleaning">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="apiVersion"/>
        <attribute name="property"/>

		<![CDATA[
            Double api = new Double(attributes.get("apiversion"));

            if (api > 33.0) {
                project.setProperty(attributes.get("property"), "RunLocalTests");
            } else {
                project.setProperty(attributes.get("property"), "");
            }
		]]>
	</scriptdef>

	<macrodef name="runTests" backtrace="true" uri="http://www.redhat.com/sfdc" description="Requests that a dependent env run all its tests - no deploy of code will transpire">
		<attribute name="masterEnv"      default="${solenopsis.env.MASTER}"    description="The environment who has the test classes to run"/>
		<attribute name="dependentEnv"   default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to run tests"/>
		<attribute name="trace"          default="${sf.trace}"                 description="Trace the call to SFDC on deploy"/>
		<attribute name="maxPoll"        default="${sf.maxPoll}"               description="The number of times to poll the SFDC environment when deploying"/>
		<attribute name="ignoreWarnings" default="${sf.ignoreWarnings}"        description="Flag, if true, denotes that a deployment should succeed even if there are warnings when deploying"/>
		<attribute name="checkOnly"      default="${sf.checkOnly}"             description="Flag, if true, denotes check the validity of the deployed files without making any changes in the organization"/>
		<attribute name="logType"        default="${sf.logType}"               description="Debugging level for running tests.  Can be None, Debugonly, Db, Profling, Callout or Detail"/>
		<attribute name="testClasses"    default="${sf.testClasses}"           description="The test classes to run"/>
        <attribute name="dryRun"         default="${sf.dryRun}"                description="If set to anything other than an empty string, will assume you do not want to deploy"/>
        <attribute name="dumpFiles"      default="${sf.dumpFiles}"             description="If not empty, will emit a build.xml that is capable of calling to SFDC"/>
        <attribute name="showPasswords"  default="${sf.showPasswords}"         description="When generating a build.xml, will contain the token/password used"/>
		<attribute name="description"    default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
			<rh-sfdc:compute-env-values env="@{dependentEnv}" username="runTests.USERNAME" webServicePassword="runTests.PASSWORD" url="runTests.URL" version="runTests.VERSION" generate-tests="runTests.GENERATE_TESTS"/>

			<rh-sfdc:xml-package property="runTests.PACKAGE" version="${runTests.VERSION}" description="Create an empty package"/>

			<rh-util:property name="runTests.tmp.DIR" value="${solenopsis.temp.DIR}/push"/>
			<delete dir="${runTests.tmp.DIR}"/>
			<mkdir dir="${runTests.tmp.DIR}"/>

			<echo message="${runTests.PACKAGE}" file="${runTests.tmp.DIR}/package.xml"/>

			<rh-util:property name="runTests.DEPLOY_FILE" value="${runTests.tmp.DIR}/deploy.zip"/>

			<zip destfile="${runTests.DEPLOY_FILE}" basedir="${runTests.tmp.DIR}" level="9"/>

			<!--
				if no test classes, we will run all tests.  Otherwise we will run the test classes denoted...
			-->
			<rh-util:ifEqual arg1="@{testClasses}" arg2="">
				<rh-util:then>
					<rh-util:ifEqual arg1="${runTests.GENERATE_TESTS}" arg2="true">
						<rh-util:then>
							<rh-util:baseName-findFilesContaining dir="${solenopsis.env.@{masterEnv}.HOME}/classes" property="runTests.TEST_CLASSES" value="testMethod" delimiter="," suffix=".cls">
								<include name="*.cls"/>
							</rh-util:baseName-findFilesContaining>
						</rh-util:then>

						<rh-util:else>
							<rh-util:ifEqual arg1="@{testClasses}" arg2="">
								<rh-util:then>
									<rh-util:property name="runTests.TEST_CLASSES" value=""/>
								</rh-util:then>
								<rh-util:else>
									<rh-util:property name="runTests.TEST_CLASSES" value="@{testClasses}"/>
								</rh-util:else>
							</rh-util:ifEqual>
						</rh-util:else>

					</rh-util:ifEqual>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="runTests.TEST_CLASSES" value="@{testClasses}"/>
				</rh-util:else>
			</rh-util:ifEqual>

			<!--
				if no test classes, we will run all tests.  Otherwise we will run the test classes denoted...
			-->
			<rh-util:ifEqual arg1="${runTests.TEST_CLASSES}" arg2="">
				<rh-util:then>
                    <echo>

				Processing:   [@{dependentEnv}]

				URL:          [${runTests.URL}]
				API:          [${runTests.VERSION}]

				Jar:          [${sf.migrationToolJar}]

				Test Classes: *** ALL TESTS ***

                    </echo>

                    <rh-sfdc:generateDeployXml dir="${runTests.tmp.DIR}" antJar="${sf.migrationToolJar}" apiVersion="${runTests.VERSION}" username="${runTests.USERNAME}" password="${runTests.PASSWORD}" serverurl="${runTests.URL}" zipFile ="${runTests.DEPLOY_FILE}" trace="@{trace}" runAllTests="true" maxPoll="@{maxPoll}" allowMissingFiles="true" checkOnly="@{checkOnly}" logType="@{logType}" ignoreWarnings="@{ignoreWarnings}" dumpFiles="@{dumpFiles}" showPasswords="@{showPasswords}"/>

                    <rh-sfdc:computeTestLevel apiVersion="${runTests.VERSION}" property="runTests.TEST_LEVEL"/>

                    <rh-util:ifEqual arg1="${runTests.TEST_LEVEL}" arg2="">
                        <rh-util:then>
                            <rh-util:ifEqual arg1="@{dryRun}" arg2="">
                                <rh-util:then>
                                    <sf:deploy username="${runTests.USERNAME}" password="${runTests.PASSWORD}" serverurl="${runTests.URL}" zipFile="${runTests.DEPLOY_FILE}" trace="@{trace}" runAllTests="true" maxPoll="@{maxPoll}" allowMissingFiles="true" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}"/>
                                </rh-util:then>

                                <rh-util:else>
                                    <echo>
                Dry run set to [@{dryRun}] - not deploying!

                Would have executed:

                    &lt;sf:deploy username="${runTests.USERNAME}" password="${runTests.PASSWORD}" serverurl="${runTests.URL}" zipFile="${runTests.DEPLOY_FILE}" trace="@{trace}" runAllTests="true" maxPoll="@{maxPoll}" allowMissingFiles="true" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}"/&gt;
                                    </echo>
                                </rh-util:else>
                            </rh-util:ifEqual>
                        </rh-util:then>

                        <rh-util:else>
                            <rh-util:ifEqual arg1="@{dryRun}" arg2="">
                                <rh-util:then>
                                    <sf:deploy username="${runTests.USERNAME}" password="${runTests.PASSWORD}" serverurl="${runTests.URL}" zipFile="${runTests.DEPLOY_FILE}" trace="@{trace}" runAllTests="true" maxPoll="@{maxPoll}" allowMissingFiles="true" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}" testLevel="RunLocalTests"/>
                                </rh-util:then>

                                <rh-util:else>
                                    <echo>
                Dry run set to [@{dryRun}] - not deploying!

                Would have executed:

                    &lt;sf:deploy username="${runTests.USERNAME}" password="${runTests.PASSWORD}" serverurl="${runTests.URL}" zipFile="${runTests.DEPLOY_FILE}" trace="@{trace}" runAllTests="true" maxPoll="@{maxPoll}" allowMissingFiles="true" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}" testLevel="RunLocalTests"/&gt;
                                    </echo>
                                </rh-util:else>
                            </rh-util:ifEqual>
                        </rh-util:else>
                    </rh-util:ifEqual>
                </rh-util:then>

				<rh-util:else>
                    <rh-sfdc:executeRunTests masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" zipFile="${runTests.DEPLOY_FILE}" trace="@{trace}" maxPoll="@{maxPoll}" ignoreWarnings="@{ignoreWarnings}" checkOnly="@{checkOnly}" logType="@{logType}" testClasses="${runTests.TEST_CLASSES}" dryRun="@{dryRun}"/>
				</rh-util:else>
			</rh-util:ifEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="diff" backtrace="true" uri="http://www.redhat.com/sfdc" description="This will push the master to SFDC dependent environments - its is an additive push">
		<attribute name="packageProperty" description="Property to hold the package for differences between @{masterEnv} and @{dependentEnv}"/>
		<attribute name="reportProperty"  description="Property to hold the difference between "/>
		<attribute name="masterEnv"       default="${solenopsis.env.MASTER}"    description="The master environment who has the correct data defined"/>
		<attribute name="dependentEnv"    default="${solenopsis.env.DEPENDENT}" description="The dependent environment from which to compute a difference"/>
		<attribute name="operation"       default="Remove"                      description="The diff operation being performed - for example the diff is a remove or an add'"/>
		<attribute name="excludes"        default="${sf.diff.dir.excludes}"     description="Directories to exclude when computing diffs"/>
		<attribute name="description"     default=""                            description="Comment regarding calling this macrodef"/>

		<sequential>
            <rh-util:ifUndefinedValue value="${solenopsis.env.@{dependentEnv}.HOME}">
                <rh-util:then>
                    <fail>
                        Please define [@{dependentEnv}] in solenopsis.ENVIRONMENTS!!!
                    </fail>
                </rh-util:then>
            </rh-util:ifUndefinedValue>

            <echo>
                I've got [@{masterEnv}] and [@{dependentEnv}]
            </echo>

			<rh-sfdc:compute-env-version env="@{dependentEnv}" failIfMissing="false" version="diff.VERSION"/>

            <rh-sfdc:xml-package property="@{packageProperty}" version="${diff.VERSION}">
				<rh-util:property name="@{reportProperty}" value="@{operation} Files (non-folders):${line.separator}"/>

				<!--
					Iterate over all non-folder based dirs...
				-->
				<rh-util:processList param="dir.SUB-DIR" list="${sf.dirs.nonFolderBased}">
					<rh-util:dirDiffMissing property="diff.FILE-MISSING" dir1="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}" dir2="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.SUB-DIR}" includes="${sf.includes.@{dir.SUB-DIR}}" excludes="@{excludes}" delimiter=":">
						<rh-util:appendProperty name="@{reportProperty}" value="    @{dir.SUB-DIR} (${sf.metadata.@{dir.SUB-DIR}}):${line.separator}"/>

						<rh-sfdc:xml-types property="@{packageProperty}" name="${sf.metadata.@{dir.SUB-DIR}}">
							<!--
								Iterate over the files, populating the report and package properties...
							-->
							<rh-util:processList param="dir.LIST-VALS" list="${diff.FILE-MISSING}" listDelimiter=":">
								<rh-util:baseName-List property="dir.FILE" file="@{dir.LIST-VALS}" suffixList="${sf.suffix.@{dir.SUB-DIR}}"/>

								<rh-util:appendProperty name="@{reportProperty}" value="        @{dir.LIST-VALS}  (${dir.FILE})${line.separator}"/>

								<rh-sfdc:xml-members property="@{packageProperty}" value="${dir.FILE}" elementDelimiter="@{elementDelimiter}"/>
							</rh-util:processList>
						</rh-sfdc:xml-types>
					</rh-util:dirDiffMissing>
				</rh-util:processList>

				<rh-util:appendProperty name="@{reportProperty}" value="${line.separator}@{operation} Files (folders):${line.separator}"/>

				<!--
					Iterate over all folder based dirs...
				-->
				<rh-util:processList param="dir.SUB-DIR" list="${sf.dirs.folderBased}">
					<rh-util:dirDiffMissing property="diff.FILE-MISSING" dir1="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}" dir2="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.SUB-DIR}" includes="${sf.includes.@{dir.SUB-DIR}}" excludes="@{excludes}" delimiter=":">
						<rh-util:appendProperty name="@{reportProperty}" value="    @{dir.SUB-DIR} (${sf.metadata.@{dir.SUB-DIR}}):${line.separator}"/>

						<rh-sfdc:xml-types property="@{packageProperty}" name="${sf.metadata.@{dir.SUB-DIR}}">
							<!--
								Iterate over the files, populating the report and package properties...
							-->
							<rh-util:processList param="dir.LIST-VALS" list="${diff.FILE-MISSING}" listDelimiter=":">
								<rh-util:baseName-List property="dir.FILE" file="@{dir.LIST-VALS}" suffixList="${sf.suffix.@{dir.SUB-DIR}}"/>

								<rh-util:appendProperty name="@{reportProperty}" value="        @{dir.LIST-VALS}  (${dir.FILE})${line.separator}"/>

								<!--
									If we are a subdir, we need the parent dir name to prefix...
								-->
								<rh-util:ifContains string="@{dir.LIST-VALS}" substring="/">
									<rh-util:then>
										<rh-util:dirName property="diff.DIR_NAME"   file="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.LIST-VALS}"/>
										<rh-util:baseName property="diff.BASE_NAME" file="${diff.DIR_NAME}"/>
										<rh-util:property name="diff.PREFIX"        value="${diff.BASE_NAME}/"/>
									</rh-util:then>

									<rh-util:else>
										<rh-util:property name="diff.PREFIX" value=""/>
									</rh-util:else>
								</rh-util:ifContains>

								<rh-sfdc:xml-members property="@{packageProperty}" value="${diff.PREFIX}${dir.FILE}" elementDelimiter="@{elementDelimiter}"/>
							</rh-util:processList>
						</rh-sfdc:xml-types>
					</rh-util:dirDiffMissing>
				</rh-util:processList>

				<rh-util:appendProperty name="@{reportProperty}" value="${line.separator}@{operation} Fields:${line.separator}"/>

				<!--
					Iterate over all dirs that support field level changes...
				-->
				<rh-util:processList param="dir.SUB-DIR" list="${sf.diff.dirs}">
					<rh-util:appendProperty name="@{reportProperty}" value="    @{dir.SUB-DIR}:${line.separator}"/>

					<!--
						Iterate over the metadata properties for XML properties...
					-->
					<rh-util:processList param="diff.METADATA" list="${sf.diff.metadata.@{dir.SUB-DIR}}">
						<rh-util:appendProperty name="@{reportProperty}" value="        ${sf.diff.property.@{dir.SUB-DIR}-@{diff.METADATA}}:${line.separator}"/>

						<!--
							Not sure we want to force this, but it can't hurt...
						-->
						<mkdir dir="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}"/>

						<!--
							Iterate over all the files for, applying metadata diffs...
						-->
						<ac:for param="diff.FILE">
							<fileset dir="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}" includes="${sf.includes.@{dir.SUB-DIR}}"/>

							<sequential>
								<rh-util:baseName property="diff.BASE-NAME" file="@{diff.FILE}"/>

								<xmlproperty file="@{diff.FILE}" prefix="@{masterEnv}.@{dir.SUB-DIR}.${diff.BASE-NAME}"/>
								<xmlproperty file="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.SUB-DIR}/${diff.BASE-NAME}" prefix="@{dependentEnv}.@{dir.SUB-DIR}.${diff.BASE-NAME}"/>

								<rh-util:propertyDereference name="diff.LIST1" property="@{masterEnv}.@{dir.SUB-DIR}.${diff.BASE-NAME}.@{diff.METADATA}"/>
								<rh-util:propertyDereference name="diff.LIST2" property="@{dependentEnv}.@{dir.SUB-DIR}.${diff.BASE-NAME}.@{diff.METADATA}"/>

								<rh-util:listDiffMissing property="diff.LIST" list1="${diff.LIST1}" list2="${diff.LIST2}" delimiter=",">
									<rh-util:baseName-List property="diff.MEMBER-PREFIX" file="${diff.BASE-NAME}" suffixList="${sf.suffix.@{dir.SUB-DIR}}"/>

									<!--
										Iterate over the list of diffs, creating xml members per type...
									-->
									<!--
									<rh-sfdc:xml-types property="@{packageProperty}" name="${sf.metadata.@{dir.SUB-DIR}}">
										-->
									<rh-sfdc:xml-types property="@{packageProperty}" name="${sf.diff.property.@{dir.SUB-DIR}-@{diff.METADATA}}">
										<rh-util:processList param="diff.DIFF-MEMBER" list="${diff.LIST}" listDelimiter=",">
											<rh-sfdc:xml-members property="@{packageProperty}" value="${diff.MEMBER-PREFIX}.@{diff.DIFF-MEMBER}" elementDelimiter="@{elementDelimiter}"/>
										</rh-util:processList>
									</rh-sfdc:xml-types>

									<rh-util:appendProperty name="@{reportProperty}" value="            ${diff.BASE-NAME}:${line.separator}"/>
									<rh-util:appendProperty name="@{reportProperty}" value="                ${diff.LIST}${line.separator}"/>
								</rh-util:listDiffMissing>
							</sequential>
						</ac:for>
					</rh-util:processList>
				</rh-util:processList>

				<!--
					Iterate over all dirs for mods...
				-->
				<rh-util:appendProperty name="@{reportProperty}" value="${line.separator}Modified Files:${line.separator}"/>
				<rh-util:processList param="dir.SUB-DIR" list="${sf.dirs}">
					<rh-util:appendProperty name="@{reportProperty}" value="    @{dir.SUB-DIR}:${line.separator}"/>

					<ac:if>
						<available file="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}"/>

						<ac:then>
							<ac:for param="diff.FILE">
								<fileset dir="${solenopsis.env.@{masterEnv}.HOME}/@{dir.SUB-DIR}"/>

								<sequential>
									<rh-util:baseName property="diff.DEPENDENT_BASE_NAME" file="@{diff.FILE}"/>

									<ac:var name="diff.DIFF_FILE_CONTENTS" unset="true"/>
									<ac:var name="diff.RESULT" unset="true"/>
									<ac:var name="diff.ERROR" unset="true"/>

									<ac:if>
										<available file="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.SUB-DIR}/${diff.DEPENDENT_BASE_NAME}"/>

										<ac:then>
											<ac:var name="diff.DIFF_FILE_DEPENDENT" unset="true"/>
											<loadfile property="diff.DIFF_FILE_DEPENDENT" srcFile="${solenopsis.env.@{dependentEnv}.HOME}/@{dir.SUB-DIR}/${diff.DEPENDENT_BASE_NAME}"/>
											<ac:var name="diff.DIFF_FILE_MASTER" unset="true"/>
											<loadfile property="diff.DIFF_FILE_MASTER" srcFile="@{diff.FILE}"/>

											<ac:if>
												<not>
													<equals arg1="${diff.DIFF_FILE_DEPENDENT}" arg2="${diff.DIFF_FILE_MASTER}"/>
												</not>

												<ac:then>
													<rh-util:appendProperty name="@{reportProperty}" value="        ${diff.DEPENDENT_BASE_NAME}${line.separator}"/>
												</ac:then>
											</ac:if>
										</ac:then>
									</ac:if>
								</sequential>
							</ac:for>
						</ac:then>
					</ac:if>
				</rh-util:processList>

				<!--
				<rh-sfdc:generate-objects-properties env="@{masterEnv}" description="Recreate the properties for the objects"/>

				<rh-util:property name="diff.mod.REPORT" value=""/>
				-->

				<!--
					Need to fix and field values (if there are variations),
					those need to be removed...
				-->
				<!--
				CANT DO THIS - ITS NOT WORKING...NEED A WAY TO DENOTE REMOVING A PICKLIST VALUE...

				<rh-sfdc:object-diff masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" property-prefix="diff.mod">
					<FieldMod>
						<rh-sfdc:xml-types property="@{packageProperty}" name="CustomField">
							<rh-sfdc:xml-members property="@{packageProperty}" value="${diff.mod.ENTITY}.${diff.mod.NAME}" elementDelimiter="@{elementDelimiter}"/>
						</rh-sfdc:xml-types>

						<rh-util:appendProperty name="diff.mod.REPORT" value="            ${diff.mod.ENTITY}.object:${line.separator}"/>
						<rh-util:appendProperty name="diff.mod.REPORT" value="                ${diff.mod.NAME}${line.separator}"/>
					</FieldMod>
				</rh-sfdc:object-diff>

				<rh-util:ifNotEqual arg1="${diff.mod.REPORT}" arg2="">
					<rh-util:then>
						<rh-util:appendProperty name="@{reportProperty}" value="    objects:${line.separator}"/>
						<rh-util:appendProperty name="@{reportProperty}" value="        CustomField:${line.separator}"/>
						<rh-util:appendProperty name="@{reportProperty}" value="${diff.mod.REPORT}"/>
					</rh-util:then>
				</rh-util:ifNotEqual>
				-->
			</rh-sfdc:xml-package>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="apply-object-properties" backtrace="true" uri="http://www.redhat.com/sfdc" description="For @{env}, apply the object propreties">
		<attribute name="env"                    description="The environment for which object properties will be applied"/>
		<attribute name="description" default="" description="Provide comment about calling this macrodef"/>

		<sequential>
			<rh-util:property name="apply-object-properties.DIR"  value="${solenopsis.env.HOME}/properties/@{env}/object"/>

			<rh-util:applyPropertyFiles>
				<fileset dir="${apply-object-properties.DIR}"/>
			</rh-util:applyPropertyFiles>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<!--
		This macro will generate the diffs in objects.  The properties set are:
			- @{property-prefix}.ENTITY:  This is the name of the object file (minus the .object suffix)
			- @{property-prefix}.NAME:    The name of the field.
			- @{property-prefix}.TYPE:    The type of the field.
			- @{property-prefix}.SIZE:    The size of the field.
			- @{property-prefix}.VALUE:   The value of the field.  Currently only set if there is a pick list.

		Please note, for adds/deletes - whatever information is found is set.  For mods, only the modified
		data is set for any property.  For example, if the modification is only on the type, then @{property-prefix}.TYPE
		will be set...@{property-prefix}.SIZE and @{property-prefix}.VALUE will be empty.
	-->
	<macrodef name="object-diff" backtrace="true" uri="http://www.redhat.com/sfdc" description="For objects, perform a diff">
		<attribute name="masterEnv"       default="${solenopsis.env.MASTER}"    description="The master environment"/>
		<attribute name="dependentEnv"    default="${solenopsis.env.DEPENDENT}" description="The dependent environment"/>
		<attribute name="property-prefix"                                       description="All property names used to denote changes will be preficed with this value"/>
		<attribute name="description"     default=""                            description="Provide comment about calling this macrodef"/>

		<element name="FieldAdd" optional="true" description="Called when a field is added"/>
		<element name="FieldDel" optional="true" description="Called when a field is removed"/>
		<element name="FieldMod" optional="true" description="Called when a field is modified"/>

		<sequential>
			<!--
				Apply all properties for comparison...
			-->
			<rh-sfdc:apply-object-properties env="@{masterEnv}"/>
			<rh-sfdc:apply-object-properties env="@{dependentEnv}"/>

			<!--
				Iterate over the master, comparing values in the master
				that are not in the dependent...
			-->
			<ac:for param="object-diff.master.FILE">
				<fileset dir="${solenopsis.env.@{masterEnv}.HOME}/objects"/>
				<sequential>
					<rh-util:baseName property="object-diff.RAW_FILE_NAME"  file="@{object-diff.master.FILE}"/>
					<rh-util:baseName property="object-diff.BASE_FILE_NAME" file="@{object-diff.master.FILE}" suffix=".object"/>
					
					<rh-util:propertyDereference name="object-diff.FIELDS"   property="solenopsis.env.@{masterEnv}.objects.fields.${object-diff.BASE_FILE_NAME}"/>

					<!--
						Does the dependent contain the file?
					-->
					<ac:if>
						<not>
							<available file="${solenopsis.env.@{dependentEnv}.HOME}/objects/${object-diff.RAW_FILE_NAME}"/>
						</not>

						<ac:then>
							<!--
								These are adds - meaning master contains fields dependent does not...
								This is an add...
							-->
							<rh-util:processList param="object-diff.field.NAME" list="${object-diff.FIELDS}" listDelimiter=",">
								<rh-util:propertyDereference name="object-diff.master.TYPE"   property="solenopsis.env.@{masterEnv}.objects.field.type.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.master.SIZE"   property="solenopsis.env.@{masterEnv}.objects.field.size.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.master.VALUE"  property="solenopsis.env.@{masterEnv}.objects.field.value.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
					
								<rh-util:property name="@{property-prefix}.ENTITY" value="${object-diff.BASE_FILE_NAME}"/>
								<rh-util:property name="@{property-prefix}.NAME"   value="@{object-diff.field.NAME}"/>
								<rh-util:property name="@{property-prefix}.TYPE"   value="${object-diff.master.TYPE}"/>
								<rh-util:property name="@{property-prefix}.SIZE"   value="${object-diff.master.SIZE}"/>
								<rh-util:property name="@{property-prefix}.VALUE"  value="${object-diff.master.VALUE}"/>

								<FieldAdd/>
							</rh-util:processList>
						</ac:then>

						<!--
							File exists, check for modifications...
						-->
						<ac:else>
							<rh-util:processList param="object-diff.field.NAME" list="${object-diff.FIELDS}" listDelimiter=",">
								<rh-util:property name="@{property-prefix}.ENTITY" value="${object-diff.BASE_FILE_NAME}"/>
								<rh-util:property name="@{property-prefix}.NAME"   value="@{object-diff.field.NAME}"/>
								<rh-util:property name="@{property-prefix}.TYPE"   value=""/>
								<rh-util:property name="@{property-prefix}.VALUE"  value=""/>
								<rh-util:property name="@{property-prefix}.SIZE"   value=""/>
								
								<rh-util:propertyDereference name="object-diff.master.TYPE"   property="solenopsis.env.@{masterEnv}.objects.field.type.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.master.SIZE"   property="solenopsis.env.@{masterEnv}.objects.field.size.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.master.VALUE"  property="solenopsis.env.@{masterEnv}.objects.field.value.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>

								<rh-util:propertyDereference name="object-diff.dependent.TYPE"   property="solenopsis.env.@{dependentEnv}.objects.field.type.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.dependent.SIZE"   property="solenopsis.env.@{dependentEnv}.objects.field.size.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.dependent.VALUE"  property="solenopsis.env.@{dependentEnv}.objects.field.value.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>

								<rh-util:ifNotEqual arg1="${object-diff.master.TYPE}" arg2="${object-diff.dependent.TYPE}">
									<rh-util:then>
										<rh-util:property name="@{property-prefix}.TYPE"  value="${object-diff.master.TYPE}"/>
									</rh-util:then>
								</rh-util:ifNotEqual>

								<rh-util:ifNotEqual arg1="${object-diff.master.SIZE}" arg2="${object-diff.dependent.SIZE}">
									<rh-util:then>
										<rh-util:property name="@{property-prefix}.SIZE"  value="${object-diff.master.SIZE}"/>
									</rh-util:then>
								</rh-util:ifNotEqual>

								<rh-util:ifNotEqual arg1="${object-diff.master.VALUE}" arg2="${object-diff.dependent.VALUE}">
									<rh-util:then>
										<rh-util:property name="@{property-prefix}.VALUE"  value="${object-diff.master.VALUE}"/>
									</rh-util:then>
								</rh-util:ifNotEqual>

								<!--
									If size, type or value not the same - this is a modification...
								-->
								<rh-util:ifNotEqual arg1="${@{property-prefix}.TYPE}${@{property-prefix}.VALUE}${@{property-prefix}.SIZE}" arg2="">
									<rh-util:then>
										<FieldMod/>
									</rh-util:then>
								</rh-util:ifNotEqual>
							</rh-util:processList>
						</ac:else>
					</ac:if>
				</sequential>
			</ac:for>

			<!--
				Iterate over the dependent, comparing values in the master
				that are not in the master...
			-->
			<ac:for param="object-diff.dependent.FILE">
				<fileset dir="${solenopsis.env.@{dependentEnv}.HOME}/objects"/>

				<sequential>
					<rh-util:baseName property="object-diff.RAW_FILE_NAME"  file="@{object-diff.dependent.FILE}"/>
					<rh-util:baseName property="object-diff.BASE_FILE_NAME" file="@{object-diff.dependent.FILE}" suffix=".object"/>

					<rh-util:propertyDereference name="object-diff.FIELDS" property="solenopsis.env.@{masterEnv}.objects.fields.${object-diff.BASE_FILE_NAME}"/>

					<!--
						Does the dependent contain the file?
					-->
					<ac:if>
						<not>
							<available file="${solenopsis.env.@{masterEnv}.HOME}/objects/${object-diff.RAW_FILE_NAME}"/>
						</not>

						<ac:then>
							<!--
								These are adds - meaning dependent contains fields dependent does not...
								This is an add...
							-->
							<rh-util:processList param="object-diff.field.NAME" list="${object-diff.FIELDS}" listDelimiter=",">
								<rh-util:propertyDereference name="object-diff.dependent.TYPE"   property="solenopsis.env.@{dependentEnv}.objects.field.type.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.dependent.SIZE"   property="solenopsis.env.@{dependentEnv}.objects.field.size.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>
								<rh-util:propertyDereference name="object-diff.dependent.VALUE"  property="solenopsis.env.@{dependentEnv}.objects.field.value.${object-diff.BASE_FILE_NAME}.@{object-diff.field.NAME}"/>

								<rh-util:property name="@{property-prefix}.ENTITY" value="${object-diff.BASE_FILE_NAME}"/>
								<rh-util:property name="@{property-prefix}.NAME"   value="@{object-diff.field.NAME}"/>
								<rh-util:property name="@{property-prefix}.TYPE"   value="${object-diff.dependent.TYPE}"/>
								<rh-util:property name="@{property-prefix}.SIZE"   value="${object-diff.dependent.SIZE}"/>
								<rh-util:property name="@{property-prefix}.VALUE"  value="${object-diff.dependent.VALUE}"/>

								<FieldDel/>
							</rh-util:processList>
						</ac:then>
					</ac:if>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<!--
		This macrodef will generate CSV files from all object files.
	-->
	<macrodef name="generate-objects-csv" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate CSV files from all object files">
		<attribute name="env"         default="${solenopsis.env.MASTER}" description="The environment for which a set of CSV files will be generated from object files"/>
		<attribute name="dir"         default="${user.home}/solenopsis/csv/@{env}/object" description="The directory to hold the CSV files generated"/>
		<attribute name="description" default="" description="Provide comment about calling this macrodef"/>

		<sequential>
			<delete dir="@{dir}"/>
			<mkdir  dir="@{dir}"/>

			<xslt basedir="${solenopsis.env.@{env}.HOME}/objects" destdir="@{dir}" style="${solenopsis.xsl.HOME}/objects/object2csv.xsl" extension=".csv"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<!--
		This macrodef will generate properties files from all object files.
	-->
	<macrodef name="generate-objects-properties" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate properties files from all properties files">
		<attribute name="env"         default="${solenopsis.env.MASTER}" description="The environment for which a set of properties files will be generated from object files"/>
		<attribute name="description" default="" description="Provide comment about calling this macrodef"/>

		<sequential>
			<rh-util:property name="generate-objects-properties.DIR"  value="${solenopsis.env.HOME}/properties/@{env}/object"/>

			<delete dir="${generate-objects-properties.DIR}"/>
			<mkdir dir="${generate-objects-properties.DIR}"/>

			<ac:for param="generate-objects-properties.FILE">
				<fileset dir="${solenopsis.env.@{env}.HOME}/objects" includes="*.object"/>

				<ac:sequential>
					<rh-util:baseName property="generate-objects-properties.BASE_NAME" file="@{generate-objects-properties.FILE}" suffix="object"/>

					<xslt in="@{generate-objects-properties.FILE}" out="${generate-objects-properties.DIR}/${generate-objects-properties.BASE_NAME}.properties" style="${solenopsis.xsl.HOME}/objects/object2properties.xsl">
						<param name="pPROPERTY_PREFIX" expression="solenopsis.env.@{env}.objects"/>
						<param name="pNAME"            expression="${generate-objects-properties.BASE_NAME}"/>
					</xslt>
				</ac:sequential>
			</ac:for>
		</sequential>
	</macrodef>


	<macrodef name="generate-objects-diff-csv" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate a CSV file containing diffs for all objects">
		<attribute name="masterEnv"    default="${solenopsis.env.MASTER}"                description="The master environment"/>
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}"             description="The dependent environment"/>
		<attribute name="file"         default="${user.home}/solenopsis-object-diff.csv" description="The CSV file to generate"/> 
		<attribute name="description"  default=""                                        description="Provide comment about calling this macrodef"/>

		<sequential>
			<!--
				Generate property files for the object files...
			-->
			<rh-sfdc:generate-objects-properties env="@{masterEnv}"/>
			<rh-sfdc:generate-objects-properties env="@{dependentEnv}"/>

			<rh-util:property name="generate-objects-diff-csv.REPORT" value=""/>

			<!--
				Compute diff...
			-->
			<rh-sfdc:object-diff masterEnv="@{masterEnv}" dependentEnv="@{dependentEnv}" property-prefix="generate-objects-diff-csv">
				<rh-sfdc:FieldAdd>
					<rh-util:appendProperty name="generate-objects-diff-csv.REPORT" value="&quot;${generate-objects-diff-csv.ENTITY}&quot;,&quot;${generate-objects-diff-csv.NAME}&quot;,&quot;New field&quot;,,&quot;${generate-objects-diff-csv.TYPE}&quot;,&quot;${generate-objects-diff-csv.SIZE}&quot;,&quot;${generate-objects-diff-csv.VALUE}&quot;${line.separator}"/>
				</rh-sfdc:FieldAdd>

				<rh-sfdc:FieldDel>
					<rh-util:appendProperty name="generate-objects-diff-csv.REPORT" value="&quot;${generate-objects-diff-csv.ENTITY}&quot;,&quot;${generate-objects-diff-csv.NAME}&quot;,&quot;Removed field&quot;,&quot;${generate-objects-diff-csv.TYPE}&quot;,&quot;${generate-objects-diff-csv.SIZE}&quot;,&quot;${generate-objects-diff-csv.VALUE}&quot;${line.separator}"/>
				</rh-sfdc:FieldDel>

				<rh-sfdc:FieldMod>
					<rh-util:appendProperty name="generate-objects-diff-csv.REPORT" value="&quot;${generate-objects-diff-csv.ENTITY}&quot;,&quot;${generate-objects-diff-csv.NAME}&quot;,&quot;Modified field&quot;,&quot;${generate-objects-diff-csv.TYPE}&quot;,&quot;${generate-objects-diff-csv.SIZE}&quot;,&quot;${generate-objects-diff-csv.VALUE}&quot;${line.separator}"/>
				</rh-sfdc:FieldMod>
			</rh-sfdc:object-diff>

			<rh-util:ifNotEqual arg1="${generate-objects-diff-csv.REPORT}" arg2="">
				<rh-util:then>
					<rh-util:prependProperty name="generate-objects-diff-csv.REPORT" value="&quot;Entity&quot;,&quot;Field Name&quot;,&quot;Action&quot;,&quot;Type&quot;,&quot;Size&quot;,&quot;Value&quot;${line.separator}"/>

					<echo message="Wrting CSV file @{file}"/>

					<echo file="@{file}" message="${generate-objects-diff-csv.REPORT}"/>
				</rh-util:then>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="describe-metadata" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate a CSV file containing diffs for all objects">
		<attribute name="dependentEnv" default="${solenopsis.env.DEPENDENT}"             description="The dependent environment"/>
		<attribute name="description"  default=""                                        description="Provide comment about calling this macrodef"/>

		<sequential>
			<!--
				Fail when no credentials found (hopefully stops one from removing any
				local versions of environments - i.e. Git)...
			-->
			<ac:if>
				<not>
					<available file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties"/>
				</not>

				<ac:then>
					<fail message="MISSING CREDENTIALS:  @{dependentEnv}  (${solenopsis.credentials.HOME}/@{dependentEnv}.properties)"/>
				</ac:then>
			</ac:if>

			<property file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties" prefix="solenopsis.env.@{dependentEnv}.credentials"/>

			<rh-util:property name="describe-metadata.USERNAME" value="${solenopsis.env.@{dependentEnv}.credentials.username}"/>
			<rh-util:property name="describe-metadata.PASSWORD" value="${solenopsis.env.@{dependentEnv}.credentials.password}${solenopsis.env.@{dependentEnv}.credentials.token}"/>
			<rh-util:property name="describe-metadata.DIR"      value="${solenopsis.env.@{dependentEnv}.HOME}"/>

			<rh-util:ifSet property="solenopsis.env.@{dependentEnv}.credentials.url">
				<rh-util:then>
					<rh-util:property name="describe-metadata.URL" value="${solenopsis.env.@{dependentEnv}.credentials.url}"/>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="describe-metadata.URL" value="${sf.url.SANDBOX}"/>
				</rh-util:else>
			</rh-util:ifSet>

			<sf:describeMetadata username="${describe-metadata.USERNAME}" password="${describe-metadata.PASSWORD}" serverurl="${describe-metadata.URL}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="list-metadata" backtrace="true" uri="http://www.redhat.com/sfdc" description="Generate a CSV file containing diffs for all objects">
		<attribute name="dependentEnv"   default="${solenopsis.env.DEPENDENT}" description="The dependent environment"/>
		<attribute name="typesDelimiter" default="${path.separator}"           description="The delimiter separating metadata types"/>
		<attribute name="types"                                                description="A space separated list of metadata types"/>
		<attribute name="description"    default=""                            description="Provide comment about calling this macrodef"/>

		<sequential>
			<!--
				Fail when no credentials found (hopefully stops one from removing any
				local versions of environments - i.e. Git)...
			-->
			<ac:if>
				<not>
					<available file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties"/>
				</not>

				<ac:then>
					<fail message="MISSING CREDENTIALS:  @{dependentEnv}  (${solenopsis.credentials.HOME}/@{dependentEnv}.properties)"/>
				</ac:then>
			</ac:if>

			<property file="${solenopsis.credentials.HOME}/@{dependentEnv}.properties" prefix="solenopsis.env.@{dependentEnv}.credentials"/>

			<rh-util:property name="list-metadata.USERNAME" value="${solenopsis.env.@{dependentEnv}.credentials.username}"/>
			<rh-util:property name="list-metadata.PASSWORD" value="${solenopsis.env.@{dependentEnv}.credentials.password}${solenopsis.env.@{dependentEnv}.credentials.token}"/>
			<rh-util:property name="list-metadata.DIR"      value="${solenopsis.env.@{dependentEnv}.HOME}"/>

			<rh-util:ifSet property="solenopsis.env.@{dependentEnv}.credentials.url">
				<rh-util:then>
					<rh-util:property name="list-metadata.URL" value="${solenopsis.env.@{dependentEnv}.credentials.url}"/>
				</rh-util:then>

				<rh-util:else>
					<rh-util:property name="list-metadata.URL" value="${sf.url.SANDBOX}"/>
				</rh-util:else>
			</rh-util:ifSet>

			<ac:for list="@{types}" param="list-metadata.PARAM" delimiter="@{typesDelimiter}">
				<sequential>
					<sf:listMetadata username="${list-metadata.USERNAME}" password="${list-metadata.PASSWORD}" serverurl="${list-metadata.URL}" metadataType="@{list-metadata.PARAM}"/>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

</project>