<!--
# Copyright 2011 Red Hat Inc.
#
# This file is part of solenopsis
#
# solenopsis is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
-->

<project name="RedHat Ant Utilities" basedir="." xmlns:ac="http://ant-contrib.sourceforge.net" xmlns:rh-util="http://www.redhat.com/util">

    <!-- =========================================================================================== -->

	<property name="rh-util.LESS_THAN"    value="&lt;" description="XML escaped less than symbol"/>
	<property name="rh-util.GREATER_THAN" value="&gt;" description="XML escaped greather than symbol"/>

    <!-- =========================================================================================== -->

	<property name="antcontrib.jar" value="${solenopsis.lib.HOME}/ant-contrib-1.0b3.jar"/>

    <!-- =========================================================================================== -->

    <taskdef resource="net/sf/antcontrib/antlib.xml" uri="http://ant-contrib.sourceforge.net" description="Needed to use ant-contrib." >
        <classpath>
            <fileset file="${antcontrib.jar}"/>
        </classpath>
    </taskdef>

    <!-- =========================================================================================== -->

	<macrodef name="baseName" backtrace="true" uri="http://www.redhat.com/util" description="Compute the basename of @{file} and store in @{property}">
		<attribute name="property"/>
		<attribute name="file"/>
		<attribute name="suffix" default=""/>

		<sequential>
			<ac:var name="baseName.PROPERTY" unset="true" value=""/>

			<ac:if>
				<equals arg1="" arg2="@{suffix}"/>
				<ac:then>
					<basename property="baseName.PROPERTY" file="@{file}"/>
				</ac:then>
				<ac:else>
					<basename property="baseName.PROPERTY" file="@{file}" suffix="@{suffix}"/>
				</ac:else>
			</ac:if>

			<ac:var name="@{property}" value="${baseName.PROPERTY}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="baseName-List" backtrace="true" uri="http://www.redhat.com/util" description="Iterate over a suffix list, and compute the basename for @{file}">
		<attribute name="property"/>
		<attribute name="file"/>
		<attribute name="suffixList"      default=""/>
		<attribute name="suffixDelimiter" default=" " description="The delimiter between each suffix found in @{suffixList}"/>

		<sequential>
			<ac:var name="baseName-List.FILE" value="@{file}"/>
			<ac:var name="@{property}" unset="true" value=""/>

			<!--
				If there is a suffix list, we will iterate over the list
				and process.  Otherwise, just go after the base name.  With
				"for" loop processing, need at least one value in the list to
				iterate - thus the need for a check here.
			-->
			<rh-util:ifNotEqual arg1="@{suffixList}" arg2="">
				<rh-util:then>
					<rh-util:processList param="baseName-List.SUFFIX" list="@{suffixList}" listDelimiter="@{suffixDelimiter}">
						<rh-util:baseName property="baseName-List.FILE" file="${baseName-List.FILE}" suffix="@{baseName-List.SUFFIX}"/>
					</rh-util:processList>

					<rh-util:property name="@{property}" value="${baseName-List.FILE}"/>
				</rh-util:then>

				<rh-util:else>
					<rh-util:baseName property="@{property}" file="${baseName-List.FILE}"/>
				</rh-util:else>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="dirName" backtrace="true" uri="http://www.redhat.com/util" description="Compute the dirname of @{file} and store in @{property}">
		<attribute name="property"/>
		<attribute name="file"/>

		<sequential>
			<ac:var name="@{property}" value="" unset="true"/>

			<dirname property="@{property}" file="@{file}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<scriptdef name="relativeDirName" uri="http://www.redhat.com/util" language="beanshell" description="Compute the dirname of @{file} and store in @{property}.  Assumes the dir may be relative and not absolute">
        <classpath refid="solenopsis.script.PATH"/>

		<attribute name="property"/>
		<attribute name="file"/>

		<![CDATA[
			import java.io.File;

			File f = new File(attributes.get("file"));

			project.setProperty(attributes.get("property"), f.getParentFile().getName());
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

	<macrodef name="dirIncludedBaseName" backtrace="true" uri="http://www.redhat.com/util" description="Compute the basename of @{file} and store the dir name plus base name in @{property}">
		<attribute name="property" description="Proprety to store result"/>
		<attribute name="file"     description="The file name to compute the directory plus basename"/>
		<attribute name="suffix" default=""/>

		<sequential>
			<rh-util:dirName  property="dirIncludedBaseName.dirName"  file="@{file}"/>
			<rh-util:baseName property="dirIncludedBaseName.baseName" file="@{file}" suffix="@{suffix}"/>

			<rh-util:property name="@{property}" value="${dirIncludedBaseName.dirName}${file.separator}${dirIncludedBaseName.baseName}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="property" backtrace="true" uri="http://www.redhat.com/util" description="Set the property @{name} to value @{value} - mutable property">
		<attribute name="name"/>
		<attribute name="value"/>

		<sequential>
			<ac:var name="@{name}" value="@{value}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="propertyDereference" backtrace="true" uri="http://www.redhat.com/util" description="Will dereference the property entitled @{property} and store the result to property entitled @{name}">
		<attribute name="name"/>
		<attribute name="property"/>

		<sequential>
			<!--
				We will dereference the property if its set...if not
				the value is the empty string...
			-->
			<rh-util:ifSet property="@{property}">
				<rh-util:then>
					<ac:var name="@{name}" value="${@{property}}"/>
				</rh-util:then>

				<rh-util:else>
					<ac:var name="@{name}" value=""/>
				</rh-util:else>
			</rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="appendProperty" backtrace="true" uri="http://www.redhat.com/util" description="Append @{value} to the property named @{name}">
		<attribute name="name"/>
		<attribute name="value"/>

		<sequential>
			<ac:if>
				<isset property="@{name}"/>
				<ac:then>
					<ac:var name="@{name}" value="${@{name}}@{value}"/>
				</ac:then>
				<ac:else>
					<ac:var name="@{name}" value="@{value}"/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="prependProperty" backtrace="true" uri="http://www.redhat.com/util" description="Prepend @{value} to the property named @{name}">
		<attribute name="name"/>
		<attribute name="value"/>

		<sequential>
			<ac:if>
				<isset property="@{name}"/>
				<ac:then>
					<ac:var name="@{name}" value="@{value}${@{name}}"/>
				</ac:then>
				<ac:else>
					<ac:var name="@{name}" value="@{value}"/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifEqual" backtrace="true" uri="http://www.redhat.com/util" description="Compares two arguments to see if they are equal.  If so, the then element is called, otherwise the else element is called">
		<attribute name="arg1"/>
		<attribute name="arg2"/>

		<element name="then" optional="false" description="If @{arg1} equals @{arg2}, this block is called"/>
		<element name="else" optional="true"  description="If @{arg1} not equals @{arg2}, this block is called"/>

		<sequential>
			<ac:if>
				<equals arg1="@{arg1}" arg2="@{arg2}"/>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifNotEqual" backtrace="true" uri="http://www.redhat.com/util" description="Compares two arguments to see if they are not equal.  If so, the then element is called, otherwise the else element is called">
		<attribute name="arg1"/>
		<attribute name="arg2"/>

		<element name="then" optional="false" description="If @{arg1} not equals @{arg2}, this block is called"/>
		<element name="else" optional="true"  description="If @{arg1} equals @{arg2}, this block is called"/>

		<sequential>
			<ac:if>
				<not>
					<equals arg1="@{arg1}" arg2="@{arg2}"/>
				</not>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifContains" backtrace="true" uri="http://www.redhat.com/util" description="Compares @{string} to see if it contains @{substring}.  If so, the then element is called, otherwise the else element is called">
		<attribute name="string"/>
		<attribute name="substring"/>

		<element name="then" optional="false" description="If @{string} contains @{substring}, this block is called"/>
		<element name="else" optional="true"  description="If @{string} does not contain @{substring}, this block is called"/>

		<sequential>
			<ac:if>
				<contains string="@{string}" substring="@{substring}"/>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifNotContains" backtrace="true" uri="http://www.redhat.com/util" description="Compares @{string} to see if it does not contain @{substring}.  If so, the then element is called, otherwise the else element is called">
		<attribute name="string"/>
		<attribute name="substring"/>

		<element name="then" optional="false" description="If @{string} does not contain @{substring}, this block is called"/>
		<element name="else" optional="true"  description="If @{string} does contain @{substring}, this block is called"/>

		<sequential>
			<ac:if>
				<not>
					<contains string="@{string}" substring="@{substring}"/>
				</not>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifSet" backtrace="true" uri="http://www.redhat.com/util" description="If @{property} is set, the then element is called, otherwise the else element is called">
		<attribute name="property"/>

		<element name="then" optional="false" description="If @{property} is set, this block is called"/>
		<element name="else" optional="true"  description="If @{property} is not set, this block is called"/>

		<sequential>
			<ac:if>
				<isSet property="@{property}"/>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifNotSet" backtrace="true" uri="http://www.redhat.com/util" description="If @{property} is not set, the then element is called, otherwise the else element is called">
		<attribute name="property"/>

		<element name="then" optional="false" description="If @{property} is set, this block is called"/>
		<element name="else" optional="true"  description="If @{property} is not set, this block is called"/>

		<sequential>
			<ac:if>
				<not>
					<isSet property="@{property}"/>
				</not>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifDefinedValue" backtrace="true" uri="http://www.redhat.com/util" description="If @{value} is defined (a string not a property), execute then block, else else block">
		<attribute name="value"/>

		<element name="then" optional="false" description="If @{property} is set, this block is called"/>
		<element name="else" optional="true"  description="If @{property} is not set, this block is called"/>

		<sequential>
			<ac:if>
				<not>
					<matches pattern="\$\{(.+)}" string="@{value}"/>
				</not>

				<ac:then>
					<then/>
				</ac:then>

				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifUndefinedValue" backtrace="true" uri="http://www.redhat.com/util" description="If @{value} is not defined (a string not a property), execute then block, else else block">
		<attribute name="value"/>

		<element name="then" optional="false" description="If @{property} is set, this block is called"/>
		<element name="else" optional="true"  description="If @{property} is not set, this block is called"/>

		<sequential>
			<ac:if>
				<matches pattern="\$\{(.+)}" string="@{value}"/>

				<ac:then>
					<then/>
				</ac:then>

				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifFileExists" backtrace="true" uri="http://www.redhat.com/util" description="If @{file} exists (either dir or file), will run the then element, otherwise the else element">
		<attribute name="file"/>

		<element name="then" optional="false" description="If @{file} exists, this block is called"/>
		<element name="else" optional="true"  description="If @{file} does not exist, this block is called"/>

		<sequential>
			<ac:if>
				<available file="@{file}"/>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="ifFileNotExists" backtrace="true" uri="http://www.redhat.com/util" description="If @{file} does not exist (either dir or file), will run the then element, otherwise the else element">
		<attribute name="file"/>

		<element name="then" optional="false" description="If @{file} does not exist, this block is called"/>
		<element name="else" optional="true"  description="If @{file} exists, this block is called"/>

		<sequential>
			<ac:if>
                <not>
                    <available file="@{file}"/>
                </not>

				<ac:then>
					<then/>
				</ac:then>
				<ac:else>
					<else/>
				</ac:else>
			</ac:if>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <macrodef name="assertFileExists" backtrace="true" uri="http://www.redhat.com/util" description="If @{file} does not exist (either dir or file), will fail">
		<attribute name="file"/>

		<sequential>
            <rh-util:ifFileNotExists file="@{file}">
                <rh-util:then>
                    <fail message="@{file} does NOT exist!"/>
                </rh-util:then>
            </rh-util:ifFileNotExists>
        </sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <macrodef name="assertFileNotExists" backtrace="true" uri="http://www.redhat.com/util" description="If @{file} exists (either dir or file), will fail">
		<attribute name="file"/>

		<sequential>
            <rh-util:ifFileExists file="@{file}">
                <rh-util:then>
                    <fail message="@{file} EXISTS!"/>
                </rh-util:then>
            </rh-util:ifFileExists>
        </sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="processList" backtrace="true" uri="http://www.redhat.com/util" description="Iterate over @{list} and process each value">
		<attribute name="param"/>
		<attribute name="list"/>
		<attribute name="listDelimiter" default=" "/>

		<element name="Process" implicit="yes"  description="Will be called for each element in @{list}"/>

		<sequential>
			<ac:for list="@{list}" param="@{param}" delimiter="@{listDelimiter}">
				<sequential>
					<Process/>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="processPropertyAsList" backtrace="true" uri="http://www.redhat.com/util" description="If property is set, treat the value of the property as a list and process">
		<attribute name="property" description="The property, if set, whose value will be iterated over for processing"/>
		<attribute name="param"/>
		<attribute name="listDelimiter" default=" "/>

		<element name="Process" implicit="yes"  description="Will be called for each element in @{list}"/>

		<sequential>
			<rh-util:ifSet property="@{property}">
				<rh-util:then>
					<rh-util:processList param="@{param}" list="${@{property}}" listDelimiter="@{listDelimiter}">
						<Process/>
					</rh-util:processList>
				</rh-util:then>
			</rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="applyPropertyFiles" backtrace="true" uri="http://www.redhat.com/util" description="Apply property files">
		<attribute name="description" default="" description="Description of why macrodef is being executed"/>

		<element name="PropertyFiles" implicit="yes" description="The fileset/dirset containing property files"/>

		<sequential>
            <ac:for param="applyPropertyFiles.file.PROPERTIES">
				<PropertyFiles/>

                <sequential>
                    <property file="@{applyPropertyFiles.file.PROPERTIES}"/>
                </sequential>
            </ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <macrodef name="branch" backtrace="true" uri="http://www.redhat.com/util" description="Compute the branch based upon a root dir, @{root}, and full path, @{fullPath}.  The branch represents the full path minus the root dir.  Please note:  if @{root} does not exist in @{fullPath}, @{property} will be set with an empty value.">
        <attribute name="property"    description="The property to set with the branch."/>
        <attribute name="root"        description="The root of the path defined in @{fullPath}."/>
        <attribute name="fullPath"    description="The absolute path for which @{root} is the root of the path and the branch computed is this path minus the root."/>
        <attribute name="description" default="" description="Information about this macro call."/>

        <sequential>
			<!-- Just in case root has too many slashes -->
			<rh-util:dirName  property="rh-util.branch.ROOT_DIR_NAME"  file="@{root}"/>
			<rh-util:baseName property="rh-util.branch.ROOT_BASE_NAME" file="@{root}"/>

			<rh-util:property  name="rh-util.branch.ROOT" value="${rh-util.branch.ROOT_DIR_NAME}${file.separator}${rh-util.branch.ROOT_BASE_NAME}"/>

            <!-- 
                Grab data past @{root} in @{fullPath}.  
            -->
			<ac:propertyregex property="rh-util.branch.BRANCH" override="true" input="@{fullPath}" regexp="${rh-util.branch.ROOT}(.*)" select="\1" description="Parse out the branch from the value contained in @{root}"/>

            <!-- 
                Remove the leading file separator (if it is there).  If it is not there,
                simply use the value as is.
            -->
            <ac:propertyregex property="@{property}" override="true" input="${rh-util.branch.BRANCH}" regexp="^[${file.separator}](.*)" replace="\1" defaultValue="${rh-util.branch.BRANCH}" description="Remove the leading file separator if its there"/>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="copyFiles" backtrace="true" uri="http://www.redhat.com/util" description="Copy files from one directory to another.  However, do so maintaining dir structure">
		<attribute name="fileList"  description="List of files to copy"/>
		<attribute name="root"      description="The root directory from fileList"/>
		<attribute name="destDir"   description="The directory to copy to"/>
		<attribute name="delimiter" default="," description="The delimiter separating fileList"/>

		<sequential>
			<rh-util:processList param="copyFiles.FILE"  list="@{fileList}" listDelimiter="@{delimiter}">
				<rh-util:branch property="copyFiles.BRANCH" root="@{root}" fullPath="@{copyFiles.FILE}"/>
				<rh-util:relativeDirName property="copyFiles.DIR" file="${copyFiles.BRANCH}"/>

				<mkdir dir="@{destDir}/${copyFiles.DIR}"/>

				<rh-util:ifFileExists file="@{copyFiles.FILE}">
					<rh-util:then>
						<copy file="@{copyFiles.FILE}" todir="@{destDir}/${copyFiles.DIR}"/>
					</rh-util:then>
				</rh-util:ifFileExists>
			</rh-util:processList>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<!--
		XXX:  Needs work when using a delimiter other than space...
	-->
	<macrodef name="fileDiff" backtrace="true" uri="http://www.redhat.com/util" description="Compare @{file1} and @{file2}.  Store the values not found in @{file1} that are in @{file2} in to property @{property}.">
		<attribute name="property"/>
		<attribute name="file1"/>
		<attribute name="file2"/>
		<attribute name="delimiter" default=" "/>

		<sequential>
			<ac:var name="@{property}" value="" unset="true"/>

			<ac:shellscript shell="bash" outputproperty="@{property}">
				diff --suppress-common-lines @{file1} @{file2} | grep "&gt;" | cut -f 2 -d '&gt;' | tr -s '\n\t' '@{delimiter}' | cut -f 2- -d'@{delimiter}'
			</ac:shellscript>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<scriptdef name="dirDiff" uri="http://www.redhat.com/util" language="beanshell" description="Compute the difference between two directories, src and dest, storing the new files in addProperty, the modified files in modProperty and the missing files in delProperty">
        <classpath refid="solenopsis.script.PATH"/>

		<attribute name="src"/>
		<attribute name="dest"/>
		<attribute name="addProperty"/>
		<attribute name="modProperty"/>
		<attribute name="delProperty"/>
		<attribute name="ignorePattern"/>
		<attribute name="delimiter"/>

		<![CDATA[
			import java.io.File;
			import java.io.RandomAccessFile;
            import java.nio.file.Files;
            import java.nio.file.FileSystem;
            import java.nio.file.FileSystems;
            import java.nio.file.Path;
			import java.util.HashSet;
			import java.util.Set;
			import java.util.TreeSet;

            boolean isDir(String file) {
                return new File(file).isDirectory();
            }

            boolean isIgnored(String file, String ignorePattern) {
                return !"".equals(ignorePattern.trim()) && file.endsWith(ignorePattern);
            }

            StringBuilder computeParentDirName(StringBuilder sb, String parentDirName) {
                if ("".equals(parentDirName.trim())) {
                    return sb;
                }

                sb.append(parentDirName).append(System.getProperty("file.separator"));

                return sb;
            }

            void gatherFiles(Set fileSet, String ignorePattern, File dir) {
                for (String fileName : dir.list()) {
                    if (isIgnored(fileName, ignorePattern)) {
                        continue;
                    }

                    File realFile = new File(dir, fileName);
                        
                    if (realFile.isDirectory()) {
                        gatherFiles(fileSet, ignorePattern, realFile);
                    } else {
                        fileSet.add(realFile);
                    }
                }
            }

            Set computeFileNames(Set fileSet, String dir) {
                Set retVal = new TreeSet();

                for (File file : fileSet) {
                    retVal.add(file.getAbsolutePath().substring(dir.length() + 1));
                }

                return retVal;
            }

            Set gatherFiles(String ignorePattern, String dir) {
                HashSet fileSet = new HashSet();
                gatherFiles(fileSet, ignorePattern, new File(dir));

                return computeFileNames(fileSet, dir);
            }

            String computeIgnorePattern() {
                return null == attributes.get("ignorepattern") ? "" : attributes.get("ignorepattern");
            }

            String computeDelimiter() {
                return null == attributes.get("delimiter") ? System.getProperty("path.separator") : attributes.get("delimiter");
            }

            String computeNotFound(Set srcTree, Set destTree, String delimiter) {
                StringBuilder sb = new StringBuilder();

                for (String src : srcTree) {
                    if (!destTree.contains(src)) {
                        sb.append(src).append(delimiter);
                    }
                }

                return sb.toString();
            }

            boolean isEqual(String src, String dest) {
                return src.replaceAll("\\s*$", "").equals(dest.replaceAll("\\s*$", ""));
            }

            String loadFile(File dir, String fileName) {
                return new String(Files.readAllBytes(FileSystems.getDefault().getPath(dir.getAbsolutePath(), new String[] {fileName})));
            }

            String computeModified(File srcDir, Set srcTree, File destDir, Set destTree, String delimiter) {
                StringBuilder sb = new StringBuilder();

                for (String src : srcTree) {
                    if (!destTree.contains(src)) {
                        continue;
                    }

                    if (isEqual(loadFile(srcDir, src), loadFile(destDir, src))) {
                        continue;
                    }

                    sb.append(src).append(delimiter);
                }

                return sb.toString();
            }

            String computeFiles(String str, String delimiter) {
                if (!str.endsWith(delimiter)) {
                    return str;
                }

                return str.substring(0, str.length() - delimiter.length());
            }

            void setAddProperty(Set srcTree, Set destTree) {
                if (null == attributes.get("addproperty")) {
                    return;
                }

                project.setProperty(attributes.get("addproperty"), computeFiles(computeNotFound(srcTree, destTree, computeDelimiter()), computeDelimiter()));
            }

            void setModProperty(Set srcTree, Set destTree) {
                if (null == attributes.get("modproperty")) {
                    return;
                }

                project.setProperty(attributes.get("modproperty"), computeFiles(computeModified(new File(attributes.get("src")), srcTree, new File(attributes.get("dest")), destTree, computeDelimiter()), computeDelimiter()));
            }

            void setDelProperty(Set srcTree, Set destTree) {
                if (null == attributes.get("delproperty")) {
                    return;
                }

                project.setProperty(attributes.get("delproperty"), computeNotFound(destTree, srcTree, computeDelimiter()));
            }

            Set srcTree = gatherFiles(computeIgnorePattern(), attributes.get("src"));
            Set destTree = gatherFiles(computeIgnorePattern(), attributes.get("dest"));

            setAddProperty(srcTree, destTree);
            setModProperty(srcTree, destTree);
            setDelProperty(srcTree, destTree);
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

	<macrodef name="dirDiffMissing" backtrace="true" uri="http://www.redhat.com/util" description="Compare @{dir1} and @{dir2}.  Store the files not found in @{dir1} that are in @{dir2} in to property @{property}.">
		<attribute name="property"/>
		<attribute name="dir1"/>
		<attribute name="dir2"/>
		<attribute name="includes"  default=""/>
		<attribute name="excludes"  default=""/>
		<attribute name="delimiter" default=" "/>

		<element name="Process" optional="true" implicit="yes" description="If anything is missing, execute the contents of this element"/>

		<sequential>
			<rh-util:property name="@{property}"              value="" description="Reset the value so if there are no files missing, the value of the property is empty"/>
			<rh-util:property name="dirDiffMissing.delimiter" value=""/>

			<!--
				Only examine @{dir2} if that directory exists
			-->
			<ac:if>
				<available file="@{dir2}"/>

				<ac:then>
					<ac:for param="rh-util.dirDiffMissing.fileName">
						<fileset dir="@{dir2}" includes="@{includes}" excludes="@{excludes}"/>

						<sequential>
							<rh-util:branch property="rh-util.dirDiffMissing.branch" root="@{dir2}" fullPath="@{rh-util.dirDiffMissing.fileName}"/>

							<ac:if>
								<not>
									<available file="@{dir1}/${rh-util.dirDiffMissing.branch}"/>
								</not>

								<ac:then>
									<rh-util:appendProperty name="@{property}" value="${dirDiffMissing.delimiter}${rh-util.dirDiffMissing.branch}"/>
									<rh-util:property name="dirDiffMissing.delimiter" value="@{delimiter}"/>
								</ac:then>
							</ac:if>
						</sequential>
					</ac:for>
				</ac:then>
			</ac:if>

			<!--
				Execute the Process element if there were any missing files...
			-->
			<rh-util:ifNotEqual arg1="${@{property}}" arg2="">
				<rh-util:then>
					<Process/>
				</rh-util:then>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="listDiffMissing" backtrace="true" uri="http://www.redhat.com/util" description="Compare @{list1} and @{list2}.  Store the values not found in @{list1} that are in @{list2} in to property @{property}.">
		<attribute name="property"/>
		<attribute name="list1"/>
		<attribute name="list2"/>
		<attribute name="delimiter" default=" "/>

		<element name="Process" optional="true" implicit="yes" description="If anything is missing, execute the contents of this element"/>

		<sequential>
			<rh-util:property name="@{property}" value="" description="Reset the value so if there are no missing items"/>
			<rh-util:property name="listDiffMissing.DELIMITER" value=""/>

			<!--
				Iterate over the second list.  Inside we will iterate over the
				first list...if we find the value from the second list in the
				first list, we will not add it...
			-->
			<rh-util:processList param="listDiffMissing.LIST2-VAL" list="@{list2}" listDelimiter="@{delimiter}">
				<!--
					Remember the value from list2.  If we find it in list1, we will set
					this property to empty.  After iterating over list1, if this property
					is not empty we know it can be added...
				-->
				<rh-util:property name="listDiffMissing.TO-FIND" value="@{listDiffMissing.LIST2-VAL}"/>

				<!--
					Iterate over list1.  If we find listDiffMissing.TO-FIND in list1, we
					won't add it.
				-->
				<rh-util:processList param="listDiffMissing.LIST1-VAL" list="@{list1}" listDelimiter="@{delimiter}">
					<rh-util:ifEqual arg1="@{listDiffMissing.LIST2-VAL}" arg2="@{listDiffMissing.LIST1-VAL}">
						<rh-util:then>
							<!--
								Value found...reset the property...it won't be added...
							-->
							<rh-util:property name="listDiffMissing.TO-FIND" value=""/>
						</rh-util:then>
					</rh-util:ifEqual>
				</rh-util:processList>

				<!--
					The property will be empty if found.  If not empty,
					we can add...
				-->
				<rh-util:ifNotEqual arg1="${listDiffMissing.TO-FIND}" arg2="">
					<rh-util:then>
						<rh-util:appendProperty name="@{property}" value="${listDiffMissing.DELIMITER}${listDiffMissing.TO-FIND}"/>
						<rh-util:property name="listDiffMissing.DELIMITER" value="@{delimiter}"/>
					</rh-util:then>
				</rh-util:ifNotEqual>
			</rh-util:processList>

			<!--
				Execute the Process element if there were any missing files...
			-->
			<rh-util:ifNotEqual arg1="${@{property}}" arg2="">
				<rh-util:then>
					<Process/>
				</rh-util:then>
			</rh-util:ifNotEqual>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="dirDiffFiles" backtrace="true" uri="http://www.redhat.com/util" description="Compare @{file1} and @{file2}.  Store the values not found in @{file1} that are in @{file2} in to property @{rpoperty}.">
		<attribute name="property"/>
		<attribute name="file1"/>
		<attribute name="file2"/>
		<attribute name="delimiter" default=" "/>

		<sequential>
			<ac:shellscript shell="bash" outputproperty="@{property}">
				diff --suppress-common-lines @{file1} @{file2} | grep "&gt;" | cut -f 2 -d '&gt;' | tr -s '\n\t' '@{delimiter}' | cut -f 2- -d'@{delimiter}'
			</ac:shellscript>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<!--
		Starting at dir, iterate over all files replacing all "variables" denoted to the properties being overridden...

		It is expected that the properties will be in the form of:
			@{prefix}.replace.[some tag].name				The name of the variable to replace
			@{prefix}.replace.[some tag].implicit			The name of the property to use for replacement - if set
			@{prefix}.replace.[some tag].default			If implicit is not set, use this as a default.

		Example:
			solenposis_replace.replace.siteAdmin.name     = SiteAdmin
			solenposis_replace.replace.siteAdmin.implicit = myfoo@solenopsis.org
			solenposis_replace.replace.siteAdmin.default  = myBackup@solenopsis.org

		It is assumed that all tags are unique and will not be duped...
	-->
	<macrodef name="replaceVariables" backtrace="true" uri="http://www.redhat.com/util" description="Iterate over files replacing variables">
		<attribute name="dir"         description="The directory to start in"/>
		<attribute name="prefix"      description="The property prefix to iterate over properties who have this prefix to perform replacement"/>
		<attribute name="description" default="" description="Provide comment about calling this macrodef"/>

		<sequential>
			<ac:var name="replaceVariables.RAW_LIST" unset="true"/>
			<ac:propertyselector property="replaceVariables.RAW_LIST" delimiter="," match="@{prefix}.replace\.(.+)\.(.+)" select="\1"/>

			<ac:sortlist property="replaceVariables.LIST" value="${replaceVariables.RAW_LIST}"/>

			<ac:var name="replaceVariables.LAST" value=""/>
			<ac:var name="replaceVariables.UNIQUE_LIST" value=""/>

			<rh-util:processList param="replaceVariables.TAG" list="${replaceVariables.LIST}" listDelimiter=",">
				<rh-util:ifNotEqual arg1="${replaceVariables.LAST}" arg2="@{replaceVariables.TAG}">
					<rh-util:then>
						<rh-util:appendProperty name="replaceVariables.UNIQUE_LIST" value="@{replaceVariables.TAG},"/>
					</rh-util:then>
				</rh-util:ifNotEqual>

				<ac:var name="replaceVariables.LAST" value="@{replaceVariables.TAG}"/>
			</rh-util:processList>

			<!--
				Iterate over the list making changes...
			-->
			<rh-util:processList param="replaceVariables.TAG" list="${replaceVariables.UNIQUE_LIST}" listDelimiter=",">
				<rh-util:ifSet property="@{prefix}.replace.@{replaceVariables.TAG}.name">
					<rh-util:then>
						<rh-util:propertyDereference name="replaceVariables.NAME" property="@{prefix}.replace.@{replaceVariables.TAG}.name"/>

						<rh-util:ifSet property="@{prefix}.replace.@{replaceVariables.TAG}.implicit">
							<rh-util:then>
								<rh-util:propertyDereference name="replaceVariables.IMPLICIT_VALUE" property="@{prefix}.replace.@{replaceVariables.TAG}.implicit"/>
							</rh-util:then>
						</rh-util:ifSet>

						<rh-util:ifSet property="@{prefix}.replace.@{replaceVariables.TAG}.default">
							<rh-util:then>
								<rh-util:propertyDereference name="replaceVariables.DEFAULT_VALUE" property="@{prefix}.replace.@{replaceVariables.TAG}.default"/>
							</rh-util:then>
						</rh-util:ifSet>

						<rh-util:ifDefinedValue value="${replaceVariables.DEFAULT_VALUE}">
							<rh-util:then>
								<rh-util:property name="replaceVariables.VALUE" value="${replaceVariables.DEFAULT_VALUE}"/>
							</rh-util:then>
						</rh-util:ifDefinedValue>

						<rh-util:ifDefinedValue value="${replaceVariables.IMPLICIT_VALUE}">
							<rh-util:then>
								<rh-util:property name="replaceVariables.VALUE" value="${replaceVariables.IMPLICIT_VALUE}"/>
							</rh-util:then>
						</rh-util:ifDefinedValue>

						<rh-util:ifSet property="replaceVariables.VALUE">
							<rh-util:then>
								<rh-util:property name="replaceVariables.TOKEN" value="${replaceVariables.NAME}"/>
								<rh-util:prependProperty name="replaceVariables.TOKEN" value="{"/>
								<rh-util:prependProperty name="replaceVariables.TOKEN" value="@"/>
								<rh-util:appendProperty name="replaceVariables.TOKEN" value="}"/>
								<replace dir="@{dir}" includes="*/**" token="${replaceVariables.TOKEN}" value="${replaceVariables.VALUE}"/>

								<!--
									ONLY GOOD IN ANT 1.7.1+!!!

								<replaceregexp match="\$\{${replaceVariables.NAME}}" replace="${replaceVariables.VALUE}">
									<fileset dir="@{dir}">
										<include name="**/**"/>
									</fileset>
								</replaceregexp>
								-->
							</rh-util:then>

							<rh-util:else>
								<echo message="Warning - no replacement value found for [@{prefix}.replace.@{replaceVariables.TAG}.name] (either implicit or default) = skipping!"/>
							</rh-util:else>
						</rh-util:ifSet>
					</rh-util:then>

					<rh-util:else>
						<echo message="Warning - cannot find a property for [${replaceVariables.VAR_NAME}] - skipping!"/>
					</rh-util:else>
				</rh-util:ifSet>
			</rh-util:processList>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

    <scriptdef name="find-files-in-zip-file" uri="http://www.redhat.com/util" language="beanshell" description="Determine if any files can be found in a zip file">
        <classpath refid="solenopsis.script.PATH"/>

		<attribute name="zipFile"/>
        <attribute name="fileList"/>
        <attribute name="baseDir"/>
        <attribute name="fileDelimiter"/>
        <attribute name="filesFound"/>

		<![CDATA[
			import java.util.zip.ZipFile;
            import java.util.zip.ZipEntry;

            String computeZipFilename(String baseDir, String fileName) {
                return fileName.startsWith(baseDir) ? fileName.substring(baseDir.length() + 1) : fileName;
            }

            String getComma(StringBuilder sb) {
                return sb.length() > 0 ? ", " : "";
            }

            addFile(StringBuilder sb, ZipEntry zipEntry, String fileName) {
                if (null == zipEntry) {
                    return;
                }

                sb.append(getComma(sb)).append(fileName);
            }

            addFile(StringBuilder sb, ZipFile zipFile, String fileName) {
                addFile(sb, zipFile.getEntry(fileName), fileName);
            }

            void addFile(StringBuilder sb, ZipFile zipFile, String baseDir, String fileName) {
                addFile(sb, zipFile, computeZipFilename(baseDir, fileName));
            }

            String getFilesInZip(ZipFile zipFile, String baseDir, String[] fileList) {
                StringBuilder retVal = new StringBuilder();

                for (String fileName : fileList) {
                    addFile(retVal, zipFile, baseDir, fileName);
                }

                return retVal.toString();
            }

            String getFilesInZip(String zipFilename, String baseDir, String[] fileList) {
                return getFilesInZip(new ZipFile(zipFilename), baseDir, fileList);
            }

            project.setProperty(attributes.get("filesfound"), getFilesInZip(attributes.get("zipfile"), attributes.get("basedir"), attributes.get("filelist").split(attributes.get("filedelimiter"))));
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

    <scriptdef name="find-value-in-files" uri="http://www.redhat.com/util" language="beanshell" description="Find all values containing @{key} in @{baseDir}">
        <classpath refid="solenopsis.script.PATH"/>

        <attribute name="baseDir"/>
        <attribute name="key"/>
        <attribute name="valuesFound"/>

		<![CDATA[
            String getFileContents(File file) {
                byte[] rawFile = new byte[file.length()];

                RandomAccessFile raf = new RandomAccessFile(file, "r");
                raf.readFully(rawFile);
                raf.close();

                return new String(rawFile);
            }

            boolean isFound(String[] values) {
                return null != values && values.length > 1;
            }

            void appendValue(String value, StringBuilder sb) {
                if (!sb.toString().endsWith(" ")) {
                    sb.append(' ');
                }

                sb.append(value);
            }

            void computeValueForLine(String[] values, StringBuilder sb) {
                if (!isFound(values)) {
                    return;
                }

                appendValue(values[1].trim(), sb);
            }

            void computeValuesForKey(String[] lines, String key, StringBuilder sb) {
                for (String line : lines) {
                    computeValueForLine(line.split(key), sb);
                }
            }

            void computeValuesForKey(File file, String key, StringBuilder sb) {
                computeValuesForKey(getFileContents(file).split(System.getProperty("line.separator")), key, sb);
            }

            void computeValuesForKey(File baseDir, String[] files, String key, StringBuilder sb) {
                for (String fileName : files) {
                    computeValuesForKey(new File(baseDir, fileName), key, sb);
                }
            }

            boolean isDirProcessable(File baseDir) {
                return baseDir.isDirectory() && baseDir.exists();
            }

            String getValuesForKey(File baseDir, String key) {
                if (!isDirProcessable(baseDir)) {
                    return "";
                }

                StringBuilder sb = new StringBuilder();

                computeValuesForKey(baseDir, baseDir.list(), key, sb);

                return sb.toString().trim();
            }

            project.setProperty(attributes.get("valuesfound"), getValuesForKey(new File(attributes.get("basedir")), attributes.get("key")));
		]]>
	</scriptdef>
    <!-- =========================================================================================== -->

	<scriptdef name="jgit-git-status" uri="http://www.redhat.com/util" language="beanshell" description="Compute git status on @{dir}, storing the changed files in @{property}">
        <classpath refid="solenopsis.script.PATH"/>

		<attribute name="addProperty"/>
		<attribute name="modProperty"/>
		<attribute name="delProperty"/>
		<attribute name="ignorePattern"/>
		<attribute name="dir"/>
		<attribute name="delimiter"/>

		<![CDATA[
			import org.eclipse.jgit.api.Status;
			import org.eclipse.jgit.lib.IndexDiff;
			import org.eclipse.jgit.storage.file.FileRepository;
			import org.eclipse.jgit.treewalk.FileTreeIterator;
			import java.io.File;
			import java.util.Set;

			File findGitDir(File dir) {
				if(null == dir) {
					return null;
				}

				File gitDir = new File(dir, ".git");

				if (gitDir.exists()) {
					return gitDir;
				}

				return findGitDir(dir.getParentFile());
			}

			String buildValues(String baseDir, String delimiter, String ignorePattern, Set values) {
				StringBuilder sb = new StringBuilder();

				for(String value : values) {
					if(!value.endsWith(ignorePattern)) {
						sb.append("".equals(baseDir) ?  value : value.substring(baseDir.length())).append(delimiter);
					}
				}

				return sb.toString();
			}

			String computeBase(File dir, File gitDir) {
				if (!dir.equals(gitDir)) {
					return dir.getPath().substring(gitDir.getParentFile().getPath().length() + 1) + System.getProperty("file.separator");
				}

				return "";
			}

			File dir = new File(attributes.get("dir"));

			File gitDir = findGitDir(dir);

			if (null == gitDir) {
				return;
			}

			FileRepository repository = new FileRepository(gitDir);
			IndexDiff indexDiff = new IndexDiff(repository, "HEAD", new FileTreeIterator(repository));

			indexDiff.diff();

			Status status = new Status(indexDiff);

			String baseDir = computeBase(dir, gitDir);

			project.setProperty(attributes.get("addproperty"), buildValues(baseDir, attributes.get("delimiter"), attributes.get("ignorepattern"), status.getUntracked()));
			project.setProperty(attributes.get("modproperty"), buildValues(baseDir, attributes.get("delimiter"), attributes.get("ignorepattern"), status.getModified()));
			project.setProperty(attributes.get("delproperty"), buildValues(baseDir, attributes.get("delimiter"), attributes.get("ignorepattern"), status.getMissing()));
		]]>
	</scriptdef>

    <!-- =========================================================================================== -->

    <macrodef name="os-shell-git-status" backtrace="true" uri="http://www.redhat.com/util" description="Call git status on @{dir}, storing the changed files in @{property}">
        <attribute name="addProperty"/>
        <attribute name="modProperty"/>
        <attribute name="delProperty"/>
        <attribute name="ignorePattern" default=""/>
        <attribute name="dir"/>
        <attribute name="delimiter" default=" " description="The delimiter to use between file names"/>
        <attribute name="description" default="" description="Description of macrdoef purpose or use"/>

        <sequential>
            <ac:var name="@{addProperty}" value="" unset="true"/>
            <ac:var name="@{modProperty}" value="" unset="true"/>
            <ac:var name="@{delProperty}" value="" unset="true"/>

            <rh-util:ifNotEqual arg1="@{ignorePattern}" arg2="">
                <rh-util:then>
                    <rh-util:property name="git-status.GREP" value="| grep -v @{ignorePattern} |"/>
                </rh-util:then>

                <rh-util:else>
                    <rh-util:property name="git-status.GREP" value="|"/>
                </rh-util:else>
            </rh-util:ifNotEqual>

            <ac:shellscript shell="bash" dir="@{dir}" outputproperty="@{addProperty}">
                git status -s . ${git-status.GREP} grep "^?? " | cut -c 4- | tr -s '\n\t' '@{delimiter}' | tr -d '"'
            </ac:shellscript>

            <ac:shellscript shell="bash" dir="@{dir}" outputproperty="@{modProperty}">
                git status -s . ${git-status.GREP} egrep "^M |^ M " | cut -c 4- | tr -s '\n\t' '@{delimiter}' | tr -d '"'
            </ac:shellscript>

            <ac:shellscript shell="bash" dir="@{dir}" outputproperty="@{delProperty}">
                git status -s . ${git-status.GREP} egrep "^ D |^ D " | cut -c 4- | tr -s '\n\t' '@{delimiter}' | tr -d '"'
            </ac:shellscript>
        </sequential>
    </macrodef>

    <!-- =========================================================================================== -->

    <macrodef name="git-status" backtrace="true" uri="http://www.redhat.com/util" description="Call git status on @{dir}, storing the changed files in @{property}">
        <attribute name="addProperty"/>
        <attribute name="modProperty"/>
        <attribute name="delProperty"/>
        <attribute name="ignorePattern" default=""/>
        <attribute name="dir"/>
        <attribute name="delimiter" default=" " description="The delimiter to use between file names"/>
        <attribute name="description" default="" description="Description of macrdoef purpose or use"/>

        <sequential>
			<rh-util:ifSet property="solenopsis.git-status.shell">
				<rh-util:then>
					<echo message="Warning:  Shelling to OS for git status"/>
					<rh-util:os-shell-git-status addProperty="@{addProperty}" modProperty="@{modProperty}" delProperty="@{delProperty}" ignorePattern="@{ignorePattern}" dir="@{dir}" delimiter="@{delimiter}"/>
				</rh-util:then>

				<rh-util:else>
					<rh-util:jgit-git-status addProperty="@{addProperty}" modProperty="@{modProperty}" delProperty="@{delProperty}" ignorePattern="@{ignorePattern}" dir="@{dir}" delimiter="@{delimiter}"/>
				</rh-util:else>
			</rh-util:ifSet>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlStartElement" backtrace="true" uri="http://www.redhat.com/util" description="Create an XML start element named @{name} and store in @{property}">
		<attribute name="property"/>
		<attribute name="name"/>
		<attribute name="namespace" default="" description="Namespace"/>
		<attribute name="attributes" default="" description="Additional attributes"/>
		<attribute name="prefix" default="" description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default=""/>

		<sequential>
			<rh-util:appendProperty name="@{property}" value="@{prefix}${rh-util.LESS_THAN}@{name}"/>

			<rh-util:ifNotEqual arg1="@{namespace}" arg2="">
				<rh-util:then>
					<rh-util:appendProperty name="@{property}" value=" xmlns=&quot;@{namespace}&quot;"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<rh-util:ifNotEqual arg1="@{attributes}" arg2="">
				<rh-util:then>
					<rh-util:appendProperty name="@{property}" value=" @{attributes}"/>
				</rh-util:then>
			</rh-util:ifNotEqual>

			<rh-util:appendProperty name="@{property}" value="${rh-util.GREATER_THAN}@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlEndElement" backtrace="true" uri="http://www.redhat.com/util" description="Create an XML end element named @{name} and store in @{property}">
		<attribute name="property"/>
		<attribute name="name"/>
		<attribute name="prefix" default="" description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default="${line.separator}"/>

		<sequential>
			<rh-util:appendProperty name="@{property}" value="@{prefix}${rh-util.LESS_THAN}/@{name}${rh-util.GREATER_THAN}@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlElement" backtrace="true" uri="http://www.redhat.com/util" description="Create an XML element whose name is @{name} and whose value is @{value} - store the element in a property name @{property}">
		<attribute name="property"/>
		<attribute name="name"/>
		<attribute name="value"/>
		<attribute name="namespace" default="" description="Namespace"/>
		<attribute name="attributes" default="" description="Additional attributes"/>
		<attribute name="prefix" default="" description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default="${line.separator}"/>

		<sequential>
			<rh-util:xmlStartElement property="@{property}" name="@{name}" namespace="@{namespace}" attributes="@{attributes}" prefix="@{prefix}"/>
			<rh-util:appendProperty  name="@{property}"     value="@{value}"/>
			<rh-util:xmlEndElement   property="@{property}" name="@{name}" elementDelimiter="@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlElementList" backtrace="true" uri="http://www.redhat.com/util" description="Generate XML element(s) each with a name of @{name}.  The value for each @{name} element is found in the @{valueDelimiter} delimited list @{values}.">
		<attribute name="property" description="Property to store the XML members element"/>
		<attribute name="name"     description="The name of the element"/>
		<attribute name="values"   description="A space delimited list of values that will be used for each members element"/>
		<attribute name="valueDelimiter"   default=" "                 description="The delimiter between each value found in @{values}"/>
		<attribute name="namespace"        default=""                  description="Namespace"/>
		<attribute name="prefix"           default=""                  description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>

		<sequential>
			<ac:for list="@{values}" param="elementValue" delimiter="@{valueDelimiter}">
				<sequential>
					<rh-util:xmlElement property="@{property}" name="@{name}" value="@{elementValue}" namespace="@{namespace}" prefix="@{prefix}" elementDelimiter="@{elementDelimiter}"/>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlElementFiles" backtrace="true" uri="http://www.redhat.com/util" description="Generate XML element(s) each with a name of @{name}.  The value for each contained in the contents of the Files element.">
		<attribute name="property" description="Property to store the XML members element"/>
		<attribute name="name"     description="The name of the element"/>
		<attribute name="suffix"           default=""                  description="The suffix to remove"/>
		<attribute name="namespace"        default=""                  description="Namespace"/>
		<attribute name="prefix"           default=""                  description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default="${line.separator}" description="The delimiter to use between elements"/>

		<element name="Files" implicit="yes" description="Represents a path, fielset, or dirset"/>

		<sequential>
			<ac:for param="elementValue">
				<Files/>
				<sequential>
					<rh-util:baseName property="xmlElementFiles.fileName" file="@{elementValue}" suffix="@{suffix}"/>
					<rh-util:xmlElement property="@{property}" name="@{name}" value="${xmlElementFiles.fileName}" namespace="@{namespace}" prefix="@{prefix}" elementDelimiter="@{elementDelimiter}"/>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="xmlElementContainer" backtrace="true" uri="http://www.redhat.com/util" description="Create an XML element whose name is @{name} - store the element in a property name @{property}.  Child elements can be created via the implicit element child">
		<attribute name="property"/>
		<attribute name="name"/>
		<attribute name="namespace"        default=""  description="Namespace"/>
		<attribute name="prefix"           default=""  description="The prefix to emit pre XML"/>
		<attribute name="elementDelimiter" default="${line.separator}"/>

		<element name="Children" optional="true" implicit="yes" description="Any child XML elements"/>

		<sequential>
			<rh-util:xmlStartElement property="@{property}" name="@{name}" namespace="@{namespace}" prefix="@{prefix}" elementDelimiter="@{elementDelimiter}"/>
				<Children/>
				<rh-util:xmlEndElement property="@{property}" name="@{name}" prefix="@{prefix}" elementDelimiter="@{elementDelimiter}"/>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="findFilesContaining" backTrace="true" backtrace="true" uri="http://www.redhat.com/util" description="Find all files containing a value">
		<attribute name="dir"         description="The directory to look for files containing a value"/>
		<attribute name="property"    description = "Property name to hold all the file names that contain a value"/>
		<attribute name="value"       description = "The value to find within the files"/>
		<attribute name="delimiter"   default="," description="Delimiter to use between file names"/>
		<attribute name="description" default="" description="Comment regarding calling this macrodef"/>

		<element name="Filter" optional="true" implicit="yes" description="Fileset child elements like include or exclude"/>

		<sequential>
			<ac:for param="findFilesContaining.FILE">
				<fileset dir="@{dir}">
					<Filter/>
				</fileset>

				<sequential>
					<ac:var name="findFilesContaining.CONTENTS" unset="true"/>
					<loadfile property="findFilesContaining.CONTENTS" srcFile="@{findFilesContaining.FILE}"/>

					<rh-util:ifContains string="${findFilesContaining.CONTENTS}" substring="@{value}">
						<rh-util:then>
							<rh-util:appendProperty name="@{property}" value="@{findFilesContaining.FILE}@{delimiter}"/>
						</rh-util:then>
					</rh-util:ifContains>
				</sequential>
			</ac:for>
		</sequential>
	</macrodef>

    <!-- =========================================================================================== -->

	<macrodef name="baseName-findFilesContaining" backTrace="true" backtrace="true" uri="http://www.redhat.com/util" description="Find all files containing a value storing the the base name of the files">
		<attribute name="dir"         description="The directory to look for files containing a value"/>
		<attribute name="property"    description = "Property name to hold all the file names that contain a value"/>
		<attribute name="value"       description = "The value to find within the files"/>
		<attribute name="suffix"      default=""  description = "The suffix to remove"/>
		<attribute name="delimiter"   default="," description="Delimiter to use between file names"/>
		<attribute name="description" default=""  description="Comment regarding calling this macrodef"/>

		<element name="Filter" optional="true" implicit="yes" description="Fileset child elements like include or exclude"/>

		<sequential>
			<rh-util:findFilesContaining dir="@{dir}" property="baseName-findFilesContaining.FILES" value="@{value}" delimiter="@{delimiter}">
				<Filter/>
			</rh-util:findFilesContaining>

			<rh-util:processList param="baseName-findFilesContaining.FILE" list="${baseName-findFilesContaining.FILES}" listDelimiter="@{delimiter}">
				<rh-util:baseName property="baseName-findFilesContaining.FILE_NAME" file="@{baseName-findFilesContaining.FILE}" suffix="@{suffix}"/>

				<rh-util:appendProperty name="@{property}" value="${baseName-findFilesContaining.FILE_NAME}@{delimiter}"/>
			</rh-util:processList>
		</sequential>
	</macrodef>
	
    <!-- =========================================================================================== -->

</project>